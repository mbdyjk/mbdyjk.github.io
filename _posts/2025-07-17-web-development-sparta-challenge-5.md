---
title: "웹개발 수업 복습 - 스파르타 챌린지반 학습자료(5)"
date: 2025-07-17
categories: [React]
tags: [React]
---

React Router DOM과 JavaScript 모듈 시스템에 대해 정리해본다.

## 1. 라우팅
: 클라이언트 요청을 적절한 서버 리소스로 연결해주는 방법, 전통적인 서버 기반 애플리케이션(MPA)에서는 url을 통해 서버에서 각기 다른 페이지를 반환, SPA는 **클라이언트 사이드 라우팅**이 사용된다.

- 라우팅 유형
  - 서버 사이드 라우팅: 각 URL이 서로 다른 HTML 파일 반환, 다른 페이지로 이동할 때마다 서버 요청이 발생해 새로고침 필요
  - 클라이언트 사이드 라우팅: URL은 변경되지만 전체 페이지를 다시 로드하진 않음(Soft Navigation)

- 클라리언트 사이트 라우팅 동작 원리
  - Path Fragment(#): URL의 # 뒤에 오는 부분, fragment가 변경되더라도 페이지 새로고침하지 않음
    - 장점: 라우팅 구현 간단, 호환성 좋음
    - 단점: URL에 #이 포함되어 덜 직관, SEO에 불리
  - history API: `history.pushState()`, `history.replaceState()`를 통해 브라우저 URL 변경, 라우터 라이브러리가 현재 URL을 분석해 적절한 컴포넌트 렌더링
    - 장점: 사용자 친화적 URL 제공, SEO에 친화적
    - 단점: 복잡도 증가

## 2. react-router-dom
: SPA에서 라우팅을 쉽게 구현하기 위한 라이브러리

- 대표기능
  - 선언적 라우팅: JSX를 통해 라우트를 선언적 정의
  - 동적 라우팅: URL 경로의 일부를 변수로 다룰 수 있음
  - Nested 라우팅: 컴포넌트 내부에 서브 라우트 정의

- 기본 라우팅 설정과 구조
  1) `createBrowerRouter`로 라우터 생성, RouterProvider에 router 지정
  2) 공용 라우트, 인증되지 않은 사용자 전용 라우트 생성
  3) 인증된 사용자 전용 라우트를 `ProtectedRoute`로 설정하여 인증되지 않은 사용자가 접근하지 못하도록 제어
  4) 인증 관리와 `AuthProvider` 설정
  5) 데이터 로딩과 `loader`, `defer` 활용
       - loader: 라우트에 접근할 때 해당 컴포넌트를 렌더링하기 전 데이터를 로드하는 함수, 미리 가져와서 보여주므로 FCP(First Contentful Paint)가 작아짐
       - defer: 데이터 로드시 모든 데이터를 기다려야 하고 특정 데이터 로드가 오래 걸릴 때, defer를 사용하면 일부 데이터를 비동기적으로 처리하여 빠르게 화면을 렌더링하고 나머지 데이터를 로드하는 동안 화면이 업데이트되도록 할 수 있음
  6) 404 페이지 처리 및 리다이렉션

## 3. 모듈 시스템
- 등장배경: JavaScript는 웹페이지에서 간단한 상호작용을 제공하기 위해 만들어졌지만, 웹 앱의 규모가 커지며 코드를 여러 파일로 분리하여 관리할 필요성이 생겼고, 이렇게 분리된 파일을 모듈, 모듈을 관리하고 사용하는 방식을 모듈 시스템

- 전역 스코프의 한계
모듈 시스템이 없던 시절 스크립트 태그를 사용해 자바스크립트 파일을 불러왔다. 하지만 이 방식은 모든 스크립트가 전역 스코프를 공유하기 때문에 변수명이 충돌하는 문제가 발생하였다.(더 뒤에 로드된 파일의 변수가 덮어씀)

- 모듈 시스템의 이점
  - 스코프 분리: 각 모듈이 독립적인 스코프를 가지므로 변수 충돌 방지
  - 코드 재사용성 향상: 공통 기능을 모듈로 분리하여 여러 곳에서 쉽게 재사용 가능
  - 유지보수 용이
  - 의존성 관리

- 모듈 시스템 종류
  - CommonJS: Node.js 환경에서 기본적으로 사용되는 모듈 시스템, .cjs 확장자 사용, `module.exports`, `require`로 모듈 내보내기/가져오기 가능, 언어 표준이 아니고 정적 분석이 어려운 문제, 비동기 모듈 정의 불가, require 함수가 재정의 가능한 문제
  - ES 모듈: 브라우저와 Node.js에서 모두 사용, .mjs 확장자 사용, `export`, `import`로 모듈 내보내기/가져오기 가능

- CommonJS와 ES 모듈 차이 비교
  - 확장자와 파일명 처리
    - CommonJS
        : 파일 확장자 생략 가능, 디렉토리를 require하면 package.json의 main 필드나 index.js 로드
    - ES 모듈
        : 파일 확장자 반드시 명시, Node.js에서 사용하려면 .mjs 확장자를 사용하거나 package.json에 "type": "module"을 설정해야 함
  - 로딩 방식
    - CommonJS
        : 동기적 로딩(require는 호출될 때 즉시 모듈 로드)
    - ES 모듈
        : 비동기적 로딩(import) => 브라우저 환경에서 성능 향상에 도움
  - 스코프
    - CommonJS
        : require는 코드 어디에서나 호출하여 동적으로 가져올 수 있음
    - ES 모듈
        : 모듈의 최상위 스코프에만 사용 가능, 동적 로딩이 필요하면 import() 함수 사용해야 함
  - 모듈 캐싱 및 순환 참조
    - CommonJS
        : 모듈이 한 번 로드되면 캐시에 저장, 순환 참조시 일부 모듈이 부분적으로 로드되어 undefined가 발생할 수 있음
    - ES 모듈
        : 모듈은 정적 분석을 통해 의존성 파악, 순환 참조시에도 변수나 함수의 선언부에 접근할 수 있음

- Node.js에서 ES 모듈 사용하는 방법
1) package.json에 설정 추가
   "type": "module"을 추가하여 프로젝트의 모든 .js 파일을 ES 모듈로 인식
2) 파일 확장자 사용
   .mjs로 파일 확장자를 변경하면 ES 모듈로 인식되고, .cjs로 변경하면 혼용 가능
