---
title: "정보처리기사 필기 책 3과목 개념문제 풀기 및 개념 정리"
date: 2025-05-10
categories: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
tags: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
---

# 정보처리기사 실기 책 3편

## 3. 데이터베이스 구축

### 76) 데이터베이스 설계
- 고려사항: 무결성(제약 조건 만족), 일관성, 회복(장애 발생 직전 상태 복구), 보안, 효율성(응답시간 단축, 저장공간 최적화), 데이터베이스 확장
- 순서
  - 요구 조건 분석: 명세 작성
  - 개념적 설계(정보 모델링): 현실 세계에 대한 인식을 추상 개념으로 표현하는 과정 -> 개념 스키마(종합 논리 구조), 트랜잭션(논리기능 작업단위) 모델링, E-R 다이어그램
  - 논리적 설계(데이터 모델링): 현실 세계 자료를 물리적 저장장치에 저장할 수 있도록 논리적 구조 데이터로 변환시키는 과정 -> 개념 스키마 평가 및 정제, 트랜잭션 인터페이스 **설계 및 작성**, 테이블 설계, DBMS에 종속적
  - 물리적 설계(데이터 구조화): 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정 -> DB 저장 구조 및 액세스 경로 결정, **레코드 관련 저장 방법 묘사**
  - 구현: DB 스키마를 파일로 생성 by DDL(데이터 정의어) -> 트랜잭션 및 응용 프로그램 작성
  
### 77) 데이터베이스 개념
- 데이터 모델: DB 스키마를 논리적으로 표현하기 위해 사용되는 도구
  - 구성 요소: 개체, 속성, 관계
  - 개념적 데이터 모델: 현실 세계 인식을 추상 개념으로 표현 ex) E-R 모델
  - 논리적 데이터 모델: 개념적 구조를 컴퓨터 세계 환경에 맞도록 변환하는 과정, 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분
  품질 검증 방식은 개체/속성/관계/식별자 품질 검증 항목이 있다.
  - 데이터 모델에 표시할 요소: 구조, 연산, 제약 조건

### 78) 데이터 모델의 구성 요소 - 개체(Entity)
- 특징: 영속적/독립적으로 존재, 식별자에 의해 구분, 개체 사이 관계 존재
- 선정 방법: 업무 기술서, 장부나 전표, 담당자와 인터뷰, 산출물, 저장소 검토, DFD(자료 흐름도) 이용시 자료 저장서 이용, BPR(업무 프로세스 재설계)에 의해 재정의시 관련 개체 찾음
- 지정 방법: 업무에서 사용하는 용어, 약어 사용 제한, 단수 명사 사용, 유일, 의미론적

### 79) 데이터 모델의 구성 요소 - 속성(Attribute)
- 종류: 기본 속성(업무 분석으로부터 도출), 설계 속성(설계 과정에서 도출한 속성, 모델링을 위해 규칙화에 사용), 파생 속성(다른 속성으로부터 영향을 받아 발생, 정합성 유지를 위해 적게 정의)
- 개체 구성 방식에 따른 분류: 기본키(개체 식별 속성), 외래키(다른 개체와의 관계), 일반
- 속성 후보 선정 원칙: 원시 속성에 해당하는 속성 후보는 버리지 않음, 가장 근접한 후보군 할당
- 속성명 지정 원칙: 업무 사용 용어, 약어 사용 제한, 서술형 지정X, 식별 가능하도록, 개체명은 속성명으로 지정하지 않는다.
* 속성 수: 차수

### 80) 데이터 모델의 구성 요소 - 관계(Relationship)
- 형태: 일대일, 일대다, 다대다
- 종류
  - 종속 관계(주종관계)
    - 식별 관계: A 개체의 기본키가 B 개체의 외래키이자 기본키가 되는 관계 -> B 개체의 존재 여부가 A 개체의 존재 여부에 의존적인 경우, ER 도형에서 실선으로 표시
    - 비식별 관계: A 개체의 기본키가 B 개체의 비기본키 영역에서 외래키가 되는 관계 -> B 개체 존재 여부는 A 개체 존재 여부와 관계없이 존재, ER 도형에서 점선으로 표시
  - 중복 관계: 두 개체 사이에 두 번 이상의 종속 관계 발생
  - 재귀 관계: 개체가 자기 자신과 관계를 가짐, 순환 관계
  - 배타 관계: 배타 AND 관계(하나만 선택)와 배타 OR 관계(하나 이상 선택 가능)
- 관계 표기 기호: |(필수), O(선택적), <(다중) -> 조합하여 관계 표시

### 81) 식별자(Identifier)
: 개체 내에서 각 인스턴스를 유일로 구분할 수 있게 함
- 분류
  - 대표성 여부
    - 주 식별자: 개체 대표하는 유일한 식별자(유일성, 최소성, 불변성, 존재성)
    - 보조 식별자: 주 식별자 대신하여 개체 식별
    물리적 테이블에서 주 식별자는 프라이머리 키로, 보조 식별자는 유니크 인덱스로 지정되어 사용
  - 스스로 생성 여부
    - 내부 식별자: 스스로 만들어지는 식별자(PK)
    - 외부 식별자: 외부 개체 식별자를 가져와 사용하는 식별자(FK)
  - 단일 속성 여부
    - 단일 식별자: 주 식별자가 한 가지 속성으로만 구성된 식별자
    - 복합 식별자: 주 식별자가 두 개 이상의 속성으로 구성
  - 대체 여부
    - 원조 식별자: 업무에 의해 만들어지는 본래 식별자
    - 대리 식별자: 주 식별자 속성이 두 개 이상인 경우(복합 식별자) 하나의 속성으로 묶어 사용하는 식별자
    -> 대리 식별자 조건: 범용적인 값 사용, 하나로 만들어져 대체되어야 함, 내부적으로만 체계화를 위해 사용할 수 있음
* 후보 식별자: 유일하게 식별할 수 있는 속성 -> 주 식별자와 보조 식별자로 나뉨, 변경이 적어야 함(보조 식별자)

### 82) E-R(개체-관계) 모델
: 개념적 데이터 모델, 개체/속성/관계로 데이터 묘사, 이후 일반화 계층 같은 복잡한 개념이 첨가되어 확장된 모델로 발전, 관계 유형 제한 없이 나타낼 수 있음
- 기호
  - 사각형: 개체 타입
  - 마름모: 관계 타입
  - 타원: 속성 타입
  - 이중 타원: 다중값 속성
  - 밑줄 타원: 기본키 속성
  - 복수 타원: 복합 속성
  - 관계(사각형, 마름모, 대응수): 1:1, 1:N, N:N 관계 대응수를 선 위에 기술
  - 선: 개체 타입과 속성 연결

### 83) 관계형 데이터 모델
: **2차원 표**를 이용해 데이터 상호 관계를 정의한 DB구조, 기본키와 외래키로 표현
관계 테이블에 외래키 존재
E-R 다이어그램을 관계형 데이터 모델로 만들 때, 별도의 관계를 만들지 않고 외래키로 속성을 추가하는 편이 간편

### 84) 관계형 데이터베이스의 구조
: 코드에 의해 제안, 개체나 관계를 relation 표로 표현, 간결하고 변환에 용이하지만 성능이 다소 떨어짐
- relation: 구조를 나타내는(속성명) 스키마와 실제 값들인 인스턴스로 구성
  - 투플: 인스턴스 행, 파일 구조에서 레코드와 같은 의미, 투플 수를 카디널리티/기수/대응수라고 함
  - 속성: 속성 수를 디그리/차수라고 함
  - 도메인: 하나의 속성이 취할 수 있는 타입의 원자값들의 집합 -> 값의 합법 여부 검사에도 사용
  - 특징: 투플의 유일성, 순서없음, 시간에 따라 변함, 속성명의 유일성 값은 겹칠 수 있음, 유일하게 식별하기 위해  기본키를 둠, 더 이상 쪼갤 수 없는 원자값을 속성값으로 설정

### 85) 관계형 데이터베이스의 제약 조건 - 키
: 투플을 찾거나 정렬시 구별하는 기준이 되는 속성
- 후보키: 기본키로 사용할 수 있는 속성들, 유일성과 최소성 만족
- 기본키: null 값을 가질 수 없는 main key
- 대체키: 후보키에서 기본키를 제외한 나머지 키
- 수퍼키: 유일성 만족, 최소성 만족하지 못하는 키, 속성들의 부분집합으로 키를 이름
- 외래키: 다른 릴레이션의 기본키를 참조하는 속성, 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음

### 86) 관계형 데이터베이스의 제약 조건 - 무결성
: db 데이터값과 실제 값이 일치하는 정확성 의미
- 종류
  - 개체 무결성: 기본키를 구성하는 어떤 속성도 null 값이나 중복값을 가질 수 없음
  - 도메인 무결성: 속성값은 도메인에 속한 값이어야 함
  - 참조 무결성: 외래키 값은 null이거나 참조 릴레이션의 기본키 값과 동일해야 함
  - 사용자 정의 무결성: 속성 값들이 제약 조건에 만족해야 함
- 데이터 무결성 강화 방법
  - 애플리케이션: 데이터 생성/추가/삭제시 무결성 조건 검증 코드 추가 -> 사용자 정의 가능, 소스 코드에 분산, 개별적 시행으로 인한 적정성 검토가 힘듬
  - 데이터베이스 트리거: 트리거 이벤트에 무결성 조건 추가 -> 통합 관리 가능, 운영 중 변경이 어려움
  - 제약 조건: db에 제약 조건 추가 -> 통합 관리 가능, 변경 용이, 복잡한 제약 조건 구현이 불가

### 87) 관계대수 및 관계해석
- 관계대수: 관계형 데이터베이스에서 릴레이션을 처리하기 위해 연산자와 연산규칙 제공
  - 순수 관계 연산자
    - Select: 선택 조건을 만족하는 릴레이션의 부분집합을 얻음, 기호: σ(시그마), 비교 연산자 및 논리 연산자 사용 -> 수평적 부분집합, FROM문
    - Project: 특정 속성 리스트만 추출, 기호: 𝝿(파이) -> 수직적 부분집합, SELECT문
    - Join: 두 릴레이션을 공통 속성 기준으로 합침, 기호: ⋈, 교차곱 후 Select와 같음, JOIN문
    * Join 조건이 = 인 경우 동일 속성이 2번 나타나 한번만 표기하도록 하는 것을 자연 Join
    - Division(카티션 프로덕트): 포함 관계에 있는 두 릴레이션에서 피포함되는 릴레이션에 해당하는 릴레이션의 투플에서 피포함 속성 제거, 기호: R[속성r÷속성s]S
  - 일반 집합 연산자
    - 합집합: U
    - 교집합: ∩
    - 차집합: -
    - 교차곱: x (순서쌍을 만듬)
- 관계해석: 관계데이터의 연산을 표현, **비절차적** 특성(원하는 정보가 무엇이라는 것만 정의), 투플/도메인 관계해석 존재, 관계대수와 관계해석은 기능면에서 동등, 프레디킷 해석
  ex) ∀(전칭 정량자): 모든 투플에 대해, ∃(존재 정량자): 하나라도 일치하는 투플 존재

### 88) 정규화
: 데이터의 중복성을 최소화하고 일관성을 보장하여 품질 보장 및 기능 향상을 위해 수행하는 작업
- 특징: 차수가 높아질수록 제약 조건 늘어남, DB 논리 설계 단계에서 수행, 일관성/정확성/단순성/비중복성/안정성 보장, 정규화 수준이 높을 수록 유연한 데이터 구축 및 정확성이 보장되지만, 접근이 복잡하고 많은 조인으로 인한 성능 저하가 발생
- 목적: 안정성과 무결성 유지, 어떤 릴레이션도 표현 가능하게, 효과적인 검색 알고리즘, 자료 저장 공간 최소화, 단순화 및 효율성, 검증 및 누락 여부 확인 가능, 이상 발생 방지
- 이상(Anormaly): 데이터들의 불필요한 중복으로 곤란한 현상
  삽입 이상(원하지 않는 값들도 함께 삽입), 삭제 이상(의도와 상관없는 값도 함께 삭제), 갱신 이상(일부만 갱신)
- 원칙: 정보의 무손실 표현, 분리의 원칙(독립된 릴레이션), 중복성 감소
- 과정
  - 1NF(제1정규형): 모든 속성 값이 원자값으로만 되어 있는 정규형
  - 2NF(제2정규형): R이 1NF이며, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족하는 정규형
  * 함수적 종속: 속성값이 기준값에 의해 종속, 완전 함수적 종속: 기본키에 의해 완전 종속, 부분 함수적 종속: 기본키의 일부에 의해만 종속
  - 3NF(제3정규형): R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는 정규형
  * 이행적 종속: A(결정자)->B(종속자), B->C일때, A->C를 만족하는 관계
  - BCNF(Boyce-Codd 정규형): 릴레이션에서 결정자가 모두 후보키인 정규형, 모든 BCNF가 종속성을 보존하는 것은 아님
    - BCNF 제약 조건: 키가 아닌 모든 속성은 각 키와 자신이 부분적으로 들어가 있지 않은 모든 키에 대해 종속적, 어떤 속성도 키기 아닌 속성에 대해 완전 종속할 수 없음
  - 4NF(제4정규형): R에 비자명한 다치 종속(A->>B; 특정 속성에만 종속) 제거
  - 5NF(제5정규형): R의 자신 프로젝션 모두를 조인한 결과가 자신과 동일한 조인 종속일 때 조인 종속이 R의 후보키로만 성립
  => 도부이결다조

### 89) 반정규화
: 정규화된 데이터 모델을 통합, 중복, 분리 -> 의도적으로 정규화 원칙 위배
WHY?) 성능/단순화 향상
- 테이블 통합: JOIN 되는 경우가 많을 때 하나의 테이블로 합침, 1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합, 레코드 추가로 인한 처리량 증가 및 규칙 복잡, 제약조건 설계가 어려움
- 테이블 분할: 수평분할(레코드-사용 빈도수에 따라), 수직분할(속성)
  - 수직 분할 종류: 갱신 위주,  자주 조회되는 속성 위주, 크기가 큰 속성, 보안 적용 필요 속성
  => 기본키 유일성 관리가 어려워짐, 수행속도 느려질 수 있음
- 중복 테이블 추가: 처리 범위를 줄이거나 특정 범위가 자주 처리될 때 사용
  - 집계 테이블 추가: 집계 데이터를 위한 테이블 생성, 원본 테이블에 트리거 설정, 오버헤드 유의
  - 진행 테이블 추가: 이력 관리 등의 목적으로 추가
  - 특정 부분만을 포함하는 테이블 추가: 특정 부분만 사용하는 경우
- 중복 속성 추가: 데이터 조회 경로 단축을 위해 자주 사용하는 속성 추가, JOIN이 자주 발생하고 복잡한 경로일 경우, SQL 그룹 함수로 해결 가능한지 검토

### 90) 시스템 카탈로그
: 시스템 자체에 관련 있는 객체 정보를 포함하는 시스템 데이터베이스 -> 데이터 사전에 저장
- 저장 정보(메타데이터)
  - DB 객체 정보: 테이블, 인덱스, 뷰
  - 사용자 정보: 아이디, 패스워드, 접근 권한
  - 무결성 제약 조건 정보: 키, NULL 값 허용 여부
  - 함수, 프로시저, 트리거 등의 정보
- 특징: SQL로 검색 가능, INSERT/DELETE/UPDATE문으로 갱신 불가, DBMS가 스스로 생성하고 유지
- DBMS 모듈 시스템
  - DDL 컴파일러: DDL을 메타데이터를 갖는 테이블로 변환하여 저장
  - DML 컴파일러: DML문을 주 언어의 프로시저 호출로 변환하여 상호 통신
  - Data Directory: 데이터 사전에 수록된 데이터를 실제 접근하는데 필요한 정보 관리 유지, 시스템만 접근 가능
  - 질의 최적화기
  - 트랜잭션 처리기
  
### 91) 사전 조사 분석
- 물리 데이터베이스 설계: 저장 레코드 양식 설계, 레코드 클러스터링의 분석 및 설계, 접근 경로 설계가 필수 포함
  물리적 설계 옵션: 반응 시간, 공간 활용도, 트랜잭션 처리량
- 데이터 명명 규칙 파악: 도메인(속성 값들에 대한 표준화 규칙), 데이터 사전(데이터 속성 명칭 부여 근거)
- 시스템 자원 파악
  - 하드웨어 자원
  - 운영체제 및 DBMS 버전
  - DBMS 파라미터 정보: 저장 공간, 메모리 등에 대한 파라미터, 옵티마이저(쿼리에서 사용) 사용방법 파악
- 데이터베이스 관리 요소 파악: DB 구조, 이중화 구성, 분산 데이터베이스, 접근제어/통제, DB 암호화

### 92) 데이터베이스 저장 공간 설계
- 테이블(논리 데이터 모델의 개체/Entity에 대응하는 객체) 종류
  - 일반 테이블: 입력되는 순서에 따라 저장
  - 클러스터드 인덱스 테이블: 기본키나 인덱스키 순서에 따라 데이터 저장, 접근 경로 단축 효과
  - 파티셔닝 테이블: 논리적 단위인 파티션으로 나눈 테이블, 파티션 키 잘못 구성시 성능 저하 역효과, 범위 분할(열의 값 기반 분할), 해시 분할(해시 함수 적용 결과 값 기반 분할), 조합 분할(범위->해시)
  - 외부 테이블: 일반 테이블처럼 사용할 수 있는 외부 파일, 객체 형태로 존재, 데이터웨어하우스에서 ETL 등의 작업에 사용
  - 임시 테이블: 트랜잭션이나 세션별로 데이터 저장 및 처리, 작업이 끝나면 삭제
- Column: 데이터 타입/길이 등으로 정의, 타입에 따른 컬럼 순서(고정 길이 앞쪽, 가변 길이 중간, null 많음 뒤에)
- 테이블스페이스: 테이블이 저장되는 논리적 영역, **테이블스페이스에 논리적** 구성 저장, **데이터파일에 물리적 구성** 저장 -> 투명성 보장
  - 설계 고려사항: 업무별 구분, 대용량테이블(LOB)은 하나의 테이블스페이스에 독립적 저장, 테이블과 인덱스 분리저장

### 93) 트랜잭션 분석/CRUD 분석
- 트랜잭션 상태: 활동->부분완료/완료(Commit) OR 실패(중단)/철회(Rollback)
- 트랜잭션 특성
  - 원자성: 트랜잭션 연산은 커밋 또는 롤백되어야 함(완벽 수행 필요)
  - 일관성: 완료시 일관성 있는 db 상태로 변환
  - 독립성: 병행 실행시 서로의 영향 x
  - 영속성: 트랜잭션 결과는 시스템이 고장나더라도 영구 반영
- CRUD 분석: 데이터 저장량 확인, 디스크 구성 자료로 활용, 부하 분산 가능
- CRUD 매트릭스: 2차원 형태 표, 행에는 프로세스를, 열에는 테이블을, 만나는 위치에 CRUD 작업 작성
  우선순위(CDUR)에 따라 표시하는 경우 존재
- 트랜잭션 분석: 데이터 저장량 유추, DB 용량 산정 및 최적화
- 트랜잭션 분석서: 단위 프로세스의 CRUD 연산과 테이블/컬럼명, 참조 횟수와 트랜잭션 수, 주기를 작성

### 94) 인덱스 설계
- 인덱스: 데이터 레코드에 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
  특징: DDL을 통해 사용자가 수정 가능, 없을 경우 TABLE SCAN으로 모든 데이터 페이지 확인 필요, 인덱스 엔트리 순서와 물리적 순서가 일치되도록 유지->클러스터드 인덱스
- 트리 기반 인덱스: 인덱스 저장 블록들이 트리 구조
  - B 트리 인덱스: 루트 노드에서 하위 노드로 키값 크기 비교하며 단말노드에서 데이터 찾음, 브랜치 블록(분기 역할, 다음 단계 포인터 가짐), 리프 블록: 인덱스에 해당하는 컬럼 데이터와 데이터 행 위치를 나타내는 레코드 식별자로 구분
  - B+ 트리 인덱스(상용 DBMS): B트리 변형, 인덱스 세트(단말 노드 제외 노드, 경로 역할)와 순차 세트(단말 노드)로 구분
- 비트맵 인덱스: 비트 값을 인덱스 키로 사용, 분포도가 좋은(조건에 맞는 레코드 수가 적은 경우) 컬럼에 적합, 효율적, 압축 효율 좋음
- 함수 기반 인덱스: 함수나 수식 적용 -> 부하 발생 가능, B+ 트리 인덱스 또는 비트맵 인덱스 생성
- 비트맵 조인 인덱스: 다수의 조인된 객체로 구성된 인덱스
- 도메인 인덱스: 필요한 인덱스 직접 만듦
- 인덱스 대상 선정 기준 키워드: 조회/액세스/조인/분포도/수정빈번하지 않고, SQL명령 빈번한 경우

### 95) 뷰 설계
: 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블
- 특징: 물리적으로 존재하진 않지만 있는 것처럼 간주, 논리적 독립성 제공, 뷰 정의시 create문, 제거시 drop문 사용, 독립적인 index를 가질 수 없고, 정의 변경 불가, 연산 제약(검색은 기본 테이블 검색 연산과 동일)

### 96) 클러스터 설계
: 데이터 저장시 액세스 효율 향상을 위해 동일 성격 데이터를 동일 데이터 블록에 저장
- 특징: **데이터 조회 속도는 향상되지만 CUD 성능은 저하**, 데이터 분포도가 넓은 경우 유리, 저장 공간 절약 가능, 처리 범위가 넓은 경우 단일 테이블 클러스터링, 조인이 많이 발생하는 경우 다중 테이블 클러스터링, 파티셔닝된 테이블에는 클러스터링 불가

### 97) 파티션 설계
- 특징: 테이블 세분화 -> 쿼리 성능 향상, 출력 분산 BUT 조인 비용 증가
- 범위 분할: 열 값 기준 분할, 데이터 집중 가능성
- 해시 분할: 해시 함수 적용, 데이터를 고르게 분산, 특정 데이터 찾기가 힘듦
- 조합 분할: 범위 분할->해시 분할
- 목록 분할: 지정한 열 값에 대한 커스텀 목록
- 라운드 로빈 분할: 레코드를 순차적으로 균일하게 분배
- 인덱스 파티션
  - 테이블 종속 여부에 따른 분류
    - Local Partitioned: 테이블 파티션과 인덱스 파티션이 1:1 대응, 관리가 쉬움
    - Global Partitioned: 테이블 파티션과 인덱스 파티션이 독립적 구성
  - 파티션키 컬럼 위치에 따른 분류
    - Prefixed Partitioned: 인덱스 파티션키와 인덱스 첫번째 컬럼이 같음
    - Non-Prefixed Partitioned: 다름

### 98) 데이터베이스 용량 설계
- 저장 공간을 정확히 산정해 확장성 및 가용성을 높임, 입출력 경합 최소화를 위해 테이블과 인덱스의 테이블스페이스 분리, 익스텐트 발생(추가 할당 공간) 최소화

### 99) 분산 데이터베이스 설계
: 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스
- 구성 요소: 분산 처리기(자체 처리 시스템), 분산 데이터베이스, 통신 네트워크
- 목표: **위치** 투명성(논리 명칭만으로 액세스), **중복** 투명성(사용자는 중복을 모르고 하나의 데이터만 존재하는 것처럼 사용), **병행** 투명성(다수의 트랜잭션이 동시 실현돼도 결과에 영향 없음), **장애** 투명성(장애에도 정확히 처리)
- 장점: 공유성 향상, 분산 제어 가능, 성능 향상, 효용성/융통성/신뢰성/가용성 높음, 점진적 시스템 용량 확장 용이, 지역 서버 자치성 보장
- 단점: 설계가 어렵고 개발 비용 증가, 처리 비용 증가, 잠재적 오류 발생 가능성
- 분할: 완전성/재구성/상호 중첩 배제 규칙 준수, 수평/수직분할
- 할당: 비중복 할당(의존성 무시, 비용 증가 및 성능 저하), 중복 할당(동일한 테이블 복제)

### 100) 데이터 베이스 이중화/서버 클러스터링
- 이중화: DB 서비스 중단이나 물리적 손상 발생시 복구를 위해 동일 데이터베이스를 복제하여 관리, 부하를 줄이고 백업 서버 운영 가능 ex) MySQL의 마스터/슬레이브 DB
  - Eager 기법: 트랜잭션 수행중 데이터 변경 발생시 이중화된 모든 데이터베이스에 즉시 적용
  - Lazy 기법: 트랜잭션 수행 종료시 변경 사실을 새 트랜잭션에 작성하여 데이터베이스에 전달
- 이중화 구성 방법: 활동-대기(장애 발생시 대기 상태 db가 대신 수행, 고가용성), 활동-활동(두 db가 서로 다른 서비스 제공하다가 장애 발생시 모두 제공, 설정 복잡, 병렬처리)
- 클러스터링: 두 대 이상의 서버를 하나의 서버로 운영 -> 서버 이중화 및 공유 스토리지로 고가용성 제공

### 101) 데이터베이스 보안 - 암호화
- 암호화: 데이터 송신에서 수신자 이외에는 알 수 없도록 암호문으로 변환
- 복호화: 암호문을 평문으로 바꾸는 과정
  - 개인키 암호 방식(**대칭** 암호 방식): **동일키**로 데이터 암호화/복호화
  - 공개키 암호 방식(**비대칭** 암호 방식): **암호화 키**는 사용자에게 공개, **복호화 키**는 관리자가 비밀리에 관리

### 102) 데이터베이스 보안 - 접근통제
- 접근통제 기술
  - 임의 접근통제(DAC;Direct): **데이터 소유자**가 데이터 접근하는 사용자 신원에 따라 접근 권한 부여, SQL 명령어로 GRANT와 REVOKE 존재
  - 강제 접근통제(MAC;Mandatory): **시스템**이 주체와 객체 등급을 비교하여 접근 권한 부여, windows 파일 권한 생각
    - **벨 라파듈라** 모델: 보안 취급자 등급을 기준으로 읽기/쓰기 권한 제어, 군대 보안레벨
    - 비바 무결성 모델: 벨 라파듈라 모델 보완, 무결성 보장
    - 클락-윌슨 무결성 모델: 무결성 중심의 상업용 모델, 사용자 접근 불가, 프로그램에 의해 접근
    - 만리장성 모델: 이해 충돌 관계에 있는 객체 간 정보 접근 통제
  - 역할기반 접근통제: **중앙관리자**가 사용자 역할에 따라 접근 권한 부여, windows 사용자 권한 생각
- 접근통제 정책
  - 신분 기반 정책: IBP(최소 권한 정책, 단일 주체에게 하나의 객체에 대한 허가), GBP(복수 주체에게 하나의 객체에 대한 허가)
  - 규칙 기반 정책: MLP(사용자/객체별 분류), CBP(집단별 분류)
  - 역할 기반 정책: GBP 변형, 주체가 맡은 역할에 근거하여 접근 제한
- 접근통제 보안 모델
  - 기밀성 모델: 군사적 목적 개발, 단순보안규칙(높은 등급의 객체 읽을 수 없음), 스타-보안규칙(낮은 등급의 객체 쓸 수 없음, 낮은 등급으로 복사하여 유출을 막음), 강한 스타-보안 규칙(자신과 다른 등급의 객체를 읽거나 쓸 수 없음)
  - 무결성 모델: 기밀성 모델에서 발생하는 불법적인 정보 변경 방지, 일관성에 중점, 단순 무결성 규칙(낮은 등급의 객체 읽을 수 없음), 스타-무결성 규칙(높은 등급의 객체에 쓸 수 없음)
  - 접근통제 모델: 접근통제 행렬로 주체와 객체 권한 유형 표시
- 접근통제 조건: 값 종속 통제(납입한 금액에 따른 보안 등급 설정), 다중 사용자 통제, 컨텍스트 기반 통제(특정 시간에만 접근 가능)
  * 인가된 사용자만 접근: 기밀성, 인가된 사용자만 수정: 무결성

### 103) 데이터베이스 백업
- 복구 알고리즘(동기적 비동기적 갱신에 따라 나눔)
  - NO-UNDO/REDO: 비동기적 갱신의 경우 복구 알고리즘(재실행)
  - UNDO/NO-REDO: 동기적 갱신의 경우 복구 알고리즘(취소해서 돌아가기)
  - UNDO/REDO: 동기/비동기 갱신의 경우 복구 알고리즘
  - NO-UNDO/NO-REDO: 동기적으로 저장 매체에 기록하지만 DB와 다른 영역에 기록한 경우 복구 알고리즘(다른 매체로부터 가져옴)
- 물리 백업: DB 파일 백업, 빠르지만 문제 발생시 해결 어려움
- 논리 백업: 논리 객체 백업, 문제 해결 수월, 느림

### 104) 스토리지
- DAS: 서버와 저장장치를 전용 케이블로 직접 연결, 컴퓨터에 외장하드 연결하는 방식이 이에 속함
  쉽고 빠르고 저렴, 다른 서버 접근 및 공유 불가, 확장성과 유연성 떨어짐
- NAS: 서버와 저장장치를 네트워크를 통해 연결, NAS Storage가 내장된 저장장치 직접 관리, 이더넷 스위치를 통해 다른 서버에서도 스토리지 접근 가능, 확장성 및 유연성 좋음, 접속 증가시 성능 저하 가능성
- SAN: DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합, **광 채널 스위치**를 이용해 네트워크 구성, 둘의 장점을 가짐
### 105) 논리적 데이터 모델의 물리 데이터 모델 변환
- 엔티티-테이블 속성-컬럼 주 식별자-기본키 외부 식별자-외래키
- 슈퍼 타입-하나의 테이블 서브 타입-여러 개의 테이블
- 슈퍼 타입과 서브 타입을 독립적 테이블로 변환하여 1:1 관계 형성 가능
- 반대로 통합하여 하나의 테이블로 만들어 검색을 쉽게하고 조인 감소

### 106) 물리 데이터 모델 품질 검토
- 품질 검토 기준: 정확성, 완전성, 준거성(표준 준수), 최신성(현행 시스템 반영), 일관성, 활용성

### 107) SQL 개념
- DDL(데이터 정의어): SCHEMA, DOMAIN, TABLE, VIEW, INDEX 정의, 변경, 삭제에 사용하는 언어
  ex) CREATE, ALTER, DROP
- DML(데이터 조작어): 데이터 처리에 사용되는 언어
  ex) SELECT(조건 검색), INSERT(삽입), DELETE(삭제), UPDATE(변경)
- DCL(데이터 제어어): 데이터 관리 목적으로 사용되는 언어
  ex) COMMIT(수행 결과 저장, 완료 알림), ROLLBACK(원래 상태 복구), GRANT(사용권한 부여), REVOKE(사용권한 취소)

### 108) DDL
- CREATE: 스키마, 도메인, 테이블, 인덱스, 뷰 정의
  
  ex) CREATE SCHEMA 스키마명 AUTHORIZATION 사용자ID

  ex) CREATE DOMAIN 도메인명 [AS] 데이터타입
      [DEFAULT 기본값]
      [CONSTRAINT 제약조건명 CHECK(범위값)]

  ex) CREATE TABLE 테이블명
      (속성명 데이터타입 [DEFAULT 기본값] [NOT NULL]
      [PRIMARY KEY(속성명)]
      [UNIQUE(속성명)]
      [FOREIGN KEY(속성명)]
        [REFERENCES 참조테이블(기본키속성명)]
        [ON DELETE 옵션]
        [ON UPDATE 옵션]
      [CONSTRAINT 제약조건명 CHECK(범위값)]);

  ex) CREATE TABLE 신규테이블명 AS SELECT 속성명 FROM 기존테이블명

  ex) CREATE VIEW 뷰명[(속성명)] AS SELECT 속성명
  
  ex) CREATE [UNIQUE] INDEX 인덱스명
      ON 테이블명(속성명 [ASC|DESC]) [CLUSTER]; -> 클러스터드 옵션은 검색을 빠르게 하지만 삽입/삭제시 재정렬 발생
- ALTER: 테이블 정의 변경(열 추가, 기본값 변경, 속성 삭제)
  
  ex) ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT 기본값];

  ex) ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT 기본값];

  ex) ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];
- DROP: 스키마, 도메인, 테이블, 뷰, 인덱스, 제약 조건 제거
  
  ex) DROP 대상 이름 [CASACADE|RESTRICT]
  CASACADE는 제거할 요소를 참조하는 모든 개체를 함께 제거, RESTRICT는 참조중일시 제거 취소

### 109) DCL
- GRANT: 권한 부여
- REVOKE: 권한 취소
  - 사용자등급 지정/해제: GRANT 사용자등급 TO 사용자ID/REVOKE 사용자등급 FROM 사용자ID
  - 테이블 및 속성에 대한 권한 부여/취소: GRANT 권한리스트 ON 개체 TO 사용자/REVOKE 권한리스트 ON 개체 FROM 사용자
    - WITH GRANT OPTION 추가시 부여받은 권한을 다른 사용자에게 다시 부여할 수 있음
    - GRANT OPTION FOR: 다른 사용자에게 권한 부여할 수 있는 권한 취소
    - CASACADE: 권한 취소시 다른 사용자에게 부여한 권한도 연쇄적으로 취소
- COMMIT: 명령에 의해 수행된 결과를 실제 물리 디스크에 저장, 완료되었음을 관리자에게 알림
- ROLLBACK: 커밋되지 않은 변경 취소, 이전상태로 복구
- SAVEPOINT: 롤백할 저장점 지정

### 110) DML
: 질의어를 통한 데이터 처리
- 삽입문: 투플 삽입
  - 방식: **INSERT INTO** 테이블명([속성명]) VALUES (값);
- 삭제문: 투플 제거
  - 방식: **DELETE FROM** 테이블명 [WHERE 조건];
- 갱신문: 투플 내용 변경
  - 방식: **UPDATE** 테이블명 SET 속성명 = 데이터 [WHERE 조건];

### 111) DML-SELECT-1
- 형식
  SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][[테이블명].속성명]
  [,그룹함수(속성명)]
  [,WINDOW함수 OVER (PARTITION BY 속성명 ORDERBY 속성명)]
  FROM 테이블명
  [WHERE 조건]
  [GROUP BY 속성명]
  [HAVING 그룹조건]
  [ORDER BY 속성명 [ASC|DESC]];
- 설명
  - PREDICATE: 불러올 투플 수 제한(ALL, DISTINCT, DISTINCTROW, TOP)
  - * : 불러올 속성명에 모든 속성 지정
  - AS: 결과 테이블의 속성명 별칭 지정
  - WHERE 조건문에 AND, OR, NOT 논리연산자와 LIKE(%로 시작/종료/포함 조건 확인), BETWEEN(-AND), IS 등의 연산자로 조건문 복잡하게 구성 가능
- 하위 질의: 조건절의 질의 먼저 수행하고 피연산자로 사용, 작업이 2개 이상일 때 사용

### 112) DML-SELECT-2
- 그룹 함수: 그룹별로 속성 값 집계
  종류: COUNT, SUM, AVG, MAX, MIN, STDDEV(표준편차), VARIANCE(분산), ROLLUP(그룹별 소계), CUBE(모든 조합의 그룹별 소계)
- WINDOW 함수: GROUP BY절을 이용하지 않고 속성 집계할 함수, PARTITION BY로 함수 범위 지정, **일련 번호/순위** 구하기, OVER와 같이 사용
  종류: ROW_NUMBER(레코드 일련번호), RANK(순위), DENSE_RANK(공동 순위 무시한 순위)
- 집합 연산자 이용한 통합 질의
  - UNION: 두 SELECT문 조회 결과 합집합
  - UNION ALL: 두 SELECT문 조회 결과 중복 포함 출력
  - INTERSECT: 두 SELECT문 조회 결과 교집합
  - EXCEPT: 두 SELECT문 조회 결과 차집합

### 113) DML-JOIN
- JOIN: 두 릴레이션을 **공통 속성** 기준으로 합쳐 반환
  - INNER JOIN
    - EQUI JOIN: 공통 속성 기준으로 equal 비교를 하여 같은 값을 가지는 행을 연결해 결과 생성
    방식: WHERE(=)문 사용, NATURAL JOIN (테이블명), JOIN 테이블명 USING(속성명) - FROM과 같이 사용
    - NON-EQUI JOIN: equal 비교가 아닌 나머지 비교 연산자로 join
  - OUTER JOIN: JOIN 조건을 만족하지 않는 투플도 결과로 출력 - FROM과 같이 사용
    - LEFT OUTER JOIN: 좌측 릴레이션 모두 표시
    - RIGHT OUTER JOIN: 우측 릴레이션 모두 표시
    - FULL OTHER JOIN: 좌측/우측 모두 표시
  - SELF JOIN: 같은 테이블에서 2개의 속성 연결

### 114) 프로시저
: 절차형 SQL(프로그래밍 언어 같이 연속적 실행이나 제어 가능한 SQL) 사용하는 트랜잭션 언어, DB에 저장, 블록 내 다른 사용자 정의 함수나 프로시저 호출
- 구성 요소: DECLARE, BEGIN/END, CONTROL(처리, 조건문/반복문), SQL, EXCEPTION(BEGIN~END 사이 예외 처리), TRANSACTION(DB 적용 여부)
- CREATE으로 프로시저 생성(OR REPLACE로 기존 대체), EXECUTE/EXEC/CALL로 프로시저 호출, IN/OUT/INOUT으로 입출력 데이터 정의

### 115) 트리거
- 생성방식: 동작시기(테이블 변경시점 기준 AFTER/BEFORE), 트리거 적용 테이블(NEW/OLD), FOR EACH ROW(각 투플마다 트리거 적용)

### 116) 사용자 정의 함수
: 일련의 작업 처리, 단일값 출력, DML 문에 포함되어 실행, 파라미터를 통해 입력만 가능, SELECT 명령만 가능

### 117) DBMS 접속 기술
: 응용 시스템(웹 서버, WAS) 매개로 DBMS에 접속, 응용 시스템은 단말기를 통해 요청을 전달받아 정해진 로직에 따라 변환하여 전달
- JDBC(Java 기반, 썬 마이크로시스템, 드라이버 필요), ODBC(마이크로소프트, 다양한 DB 접근, 드라이버 필요, 종류 몰라도 됨), MyBatis(JDBC 단순화, SQL Mapping 기반 오픈 소스 접속 프레임워크, sql 거의 그대로 사용 가능)
- 정적 SQL(커서 처리, 빠름, 사전 검사 가능) VS 동적 SQL(문자열 변수에 담음, NVL(null 처리) 사용하지 않음, 느리고 사전 검사 불가)

### 118) SQL 테스트
- 단문 SQL 테스트
  - DESC: 테이블 정보 확인
  - SHOW: 접근 권한 확인
- 절차형 SQL 테스트
  - SHOW ERRORS 명령으로 오류 내용 확인

### 119) ORM
: 객체와 관계형 데이터베이스의 데이터 연결 기술
- 특징: ORM으로 생성된 가상의 객체들은 DB와 독립적 -> 재사용성, 유지보수 용이, 간단하게 데이터 조작 및 연결 가능

### 120) 쿼리 성능 최적화
- 방법: 성능 측정 도구인 APM 사용, 옵티마이저가 수립한 실행 계획 검토
- RBO(규칙 기반 옵티마이저): 규칙에 정의된 우선순위, 개발자 숙련도에 의존, 예측 상대적 쉬움
- CBO(비용 기반 옵티마이저): 비용에 따른 우선순위, 옵티마이저 예측에 의존, 예측 복잡
- 실행 계획: EXPLAIN 명령어를 통해 확인 가능, 조인/검색/필터/정렬 등의 연산 순서 확인
- 쿼리 성능 최적화: SQL 코드와 인덱스 재구성 작업
  - SQL 코드 재구성 방법: WHERE로 범위 좁히기, WHERE에 연산자 사용 자제(인덱스 활용 불가해짐), 특정 데이터 존재 확인시 EXISTS 사용, 옵티마이저 실행 계획 잘못되었다고 판단할 경우 힌트 활용
  - 인덱스 재구성 방법: 인덱스 추가 및 열 순서 변경, 읽기로만 사용되는 테이블일 경우 IOT 구성 고려, 불필요한 인덱스 제거

### 121) 데이터 전환
- 데이터 전환: 기존 정보 시스템 데이터를 추출하여 새로 개발할 정보 시스템에서 운영할 수 있게 변환 후 적재
- 데이터 전환 계획서: 데이터 전환 작업에 필요한 모든 계획 기록

### 122) 데이터 전환 계획서 작성
- 작성 방법: 데이터 전환 목표는 간결하게 정의, 데이터 전환 환경은 원천 시스템과 목적 시스템의 구성도/전환 단계별 DISK 사용량 기술, 조직도 작성시 작업자별 역할 상세히 정리, 일정 작성시 작업별 상세 일정 수립

### 123) 데이터 전환 방안
- 방안 작성 방법: 데이터 흐름도 작성, 대량의 데이터 테이블은 미리 작성, 전환 프로그램은 목록별 작성, 단위 업무별로 전제조건과 함께 작성

### 124) 데이터 검증
- 검증 방법: 로그 검증, 기본 항목 검증, 응용 프로그램 검증, 응용 데이터 검증, 값 검증

### 125) 오류 데이터 측정 및 정제
- 오류 데이터 측정: 원천 데이터를 분석하여 정합성 여부 확인 및 오류 데이터 유형 및 건수 측정
- 오류 데이터 분석: 상태(Open/Assigned/Fixed/Closed/Deferred(연기)/Classified(오류아님)), 심각도
- 오류 데이터 정제: 원천 데이터 정제 및 전환 프로그램 수정

### 126) 데이터 정제요청서 및 정제보고서
- 데이터 정제요청서: 원천 데이터와 원천 프로그램의 수정을 위해 정제와 관련된 내용 문서화
- 데이터 정제보고서: 정제 결과를 확인한 후 결과 반영 보고서
  - 특징: 정제ID별로 작성, 육안으로 일일이 비교, 오류 데이터 원인과 대응 방안 함께 작성