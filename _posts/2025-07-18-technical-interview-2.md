---
title: "웹 프론트엔드 개발자가 되기 위한 모의 기술 면접 내용 정리 2탄"
date: 2025-07-18
categories: [Next.js, React, TypeScript, 기술 면접]
tags: [Next.js, React, TypeScript, 기술 면접]
---

기술면접질문 완벽대비를 위한 다양한 질문들의 답변을 정리한다.
출처: 내일배움캠프 React 프론트엔드 개발자 양성과정 기술면접대비 완벽대비

1. 브라우저의 렌더링 과정에 대해 설명해주세요.

    Answer: 브라우저 렌더링 과정은 HTML 파싱, CSS 파싱, 파싱 결과인 DOM 트리와 CSSOM 트리 결합, 레이아웃 계산, 페인팅 단계로 이루어집니다.

2. 쿼리 스트링은 주로 어디에 사용하셨나요?

    Answer: 저는 쿼리 스트링을 주로 검색 기능 구현에서 사용하였습니다. 이렇게 검색 기능에 쿼리 스트링을 이용하면 URL이 바뀜에 따라 브라우저 히스토리 스택에 쌓여 앞, 뒤로 가기에 수월하고, 검색 결과 공유시 다른 사람들도 URL을 통해 원하는 결과를 얻을 수 있다는 장점이 있습니다.

3. 브라우저에 URL을 입력하면 일어나는 일에 대해 순서대로 설명해주세요.

    Answer: 브라우저에 URL을 입력하면 일어나는 일을 단계별로 설명해드리겠습니다. 입력시 브라우저는 URL에서 프로토콜, 도메인 이름, 경로, 쿼리 스트링 등을 분석하게 됩니다. 이후 브라우저는 도메인 이름을 IP 주소로 변환하고자 DNS에 요청을 보냅니다. 그러면 DNS로부터 도메인에 해당하는 IP 주소를 응답으로 받습니다. 그리고 브라우저는 TCP 네트워크 연결을 구축하여 해당 IP 주소를 가진 웹 서버에 접근하여 데이터를 요청합니다. 그러면 웹서버는 HTTP 응답을 브라우저에 보내고, 브라우저는 받은 HTML CSS JS 코드를 화면에 렌더링하게 됩니다.

4. 정규 표현식을 사용해본 경험이 있으신가요?

    Answer: 네, 저는 사용자 입력 데이터를 검증할 때 정규 표현식을 사용했습니다. 예를 들어 비밀번호를 검증할 때 대문자, 숫자, 특수문자를 포함하는지 검증하고자 정규 표현식을 사용했습니다.

5. 크로스 브라우징이 무엇인가요?

    Answer: 여러 브라우저 사이에 오류 없이 같은 경험을 제공하는 브라우저 환경을 의미합니다. 저는 shadcn ui 라이브러리를 활용하여 비밀번호 입력 폼을 만들었는데, 입력 후 포커스를 이동한 뒤 다시 입력을 이어갈 때 비밀번호를 보이게 하는 눈알 아이콘이 활성화되지 않는 문제를 발견하였습니다. 문제를 확인하던 중, edge 브라우저에서만 발생하는 문제임을 알게 되었습니다. 이후로는 크로스 브라우징에 관심을 갖게 되었고, cypress 같은 E2E 테스트 도구를 사용해 각 브라우저 환경에서 테스트를 진행해보고 싶은 마음이 들었습니다.

6. lazy-loading에 대해 알고 계신가요?

    Answer: 네, 지연 로딩은 화면에 있는 ui 요소들을 렌더링 할 때 모든 요소들이 로딩된 후 표시하는 것이 아닌, 화면에 보이는 부분과 같이, 먼저 로딩이 된 부분들을 표시하고 나머지 부분들은 지연시켜 로딩하는 것을 의미합니다. 저는 검색 결과 표시를 할 때 이미지 로딩이 다수 필요하였는데, React.lazy로 동적 로딩을 구현하였고, Suspense를 통해 비동기 처리와 폴백을 구현하였습니다.

7. CORS 오류가 나는 이유에 대해 알고 계신가요?

    Answer: 네, CORS는 개념상으로 서로 다른 출처 사이의 리소스 공유 정책을 의미합니다. 즉, CORS 오류는 서로 다른 도메인 간에 데이터를 주고 받을 때 발생하는 오류압니다. 기본적으로 브라우저는 동일 출처 정책을 가지므로 발생한 문제인데, 해결책으로는 일종의 화이트리스트인 Access Control Allow Origin 헤더를 설정하는 방법이 있습니다. 미리 알려둔 출처끼리는 데이터 공유를 허가할 수 있고, Supabase에서 이미지를 bucket이라는 공간에 보관할 때 미리 규칙을 설정하여 이미지를 저장했던 경험이 있습니다. 
    
8. favicon이 무엇인지 알고 계신가요?

    Answer: 네, 파비콘은 웹 브라우저 탭의 타이틀 좌측에 존재하는 조그만한 아이콘을 의미합니다. 해당 웹사이트의 브랜드 이미지를 나타내고, svg로 애플리케이션 배포시 만들어 지정했던 경험이 있습니다. Next.js의 경우 app router에서 app 폴더의 루트에 favicon.ico 파일을 넣어주기만 하게 되어 쉽게 설정할 수 있습니다.

9. babel과 같은 트랜스파일러의 역할에 대해 설명해주세요.
    
    Answer: 바벨 같은 트랜스파일러의 역할은 최신 자바스크립트 코드를 이전 브라우저에서도 실행될 수 있도록 변환하는 것입니다. 웹 표준이 빠르게 발전함에 따라 이전 브라우저에서 호환되지 않은 기능들이 존재할 수 있습니다. 이 때, 트랜스파일러는 보편적인 브라우저에서도 실행할 수 있는 코드로 다운그레이드하여 변환해 줍니다. 만약 ECMAScript에 새 기능을 추가하려고 하면 폴리필 코드를 추가하여 구현할 수 있습니다.

10. eslint같은 linter가 중요한 이유를 설명해주세요.

    Answer: linter는 코드 품질을 향상시키고, 코드의 일관성을 유지하게 해주는 도구입니다. 특히, 개발자들 간의 협업에 있어서 코드 스타일을 일관되게 유지하는 linter 도입은 유지 보수에 도움이 됩니다. 실제로 제주 일정 공유 프로젝트를 진행할 때, 팀원들끼리 주기적으로 빌드를 같이 하며 linter 규칙에 어긋난 안티코드를 고칠 수 있었습니다.

11. 웹팩같은 bundler에 대해 알고 계신가요?

    Answer: 네, 번들러는 여러 자바스크립트 모듈과 파일들을 하나로 합쳐주는 도구입니다. 웹 앱을 제작하며 모듈과 파일 단위로 나눠 작업을 하게 되는데, 번들러는 이런 파일들을 하나로 묶어주며 최적화를 통해 코드를 압축해주는 작업을 합니다. 최근 Next.js나 Vite 사용이 대세가 되며, turbopack 등이 각광받고 있습니다.

12. 쿠키, 세션, 웹스토리지의 차이를 설명해주세요.

    Answer: 쿠키, 세션, 웹스토리지는 모두 웹에서 데이터를 저장하는 기술입니다. 순서대로 설명드리겠습니다. 먼저 쿠키는 클라이언트와 서버 간의 데이터를 저장하여 HTTP 통신에 사용됩니다. 주로 로그인 인증처리나 데이터 수집을 통한 추천 서비스 제공 등에 사용됩니다.
    다음으로 세션은 서버에서 사용자 정보를 유지하는 방법입니다. 세션이 유지되는 동안 사용자의 로그인 상태가 유지됩니다.
    웹 스토리지는 로컬 스토리지, 세션 스토리지가 많이 사용됩니다. 웹 스토리지를 통해 서버로 전송하지 않고 데이터를 저장할 수 있지만, 탈취될 가능성이 있어 민감한 정보를 저장하는 것은 개발자들 간의 협의가 필요합니다. 둘의 차이도 설명하자면, 로컬 스토리지는 브라우저를 닫아도 데이터가 유지되는 반면, 세션 스토리지는 세션 동안만 데이터가 유지되고, 브라우저를 닫으면 데이터가 사라집니다.

13. Optimistic Update에 대해 설명해주세요.

    Answer: 낙관적 업데이트는 말그대로 업데이트를 낙관적으로 잘되었으리라 생각하고 업데이트 하는 방식입니다. 보통 서버에 업데이트 요청을 보내고, 클라이언트는 서버의 응답을 받아 새로운 정보를 화면에 렌더링하게 됩니다. 하지만 이 서버를 거치는 과정에 시간이 걸리는 단점이 있어, 사용자 경험 개선을 위해 미리 응답 상태를 예측하여 화면에 적용하는 방법이 낙관적 업데이트입니다. 느린 네트워크 환경에서뿐 아니라 사용자 경험 측면에서도 유용하지만, 서버와 클라이언트 간에 상태가 같은지 확인하는 과정도 반드시 필요합니다.

14. 인증/인가 관점에서 세션 방식과 JWT 방식의 차이점을 자세히 설명해주세요. 각 방식의 장단점과 실제 프로젝트 활용 경험이 있다면 공유해주세요.

    Answer: 네, 둘의 차이에 대해 설명드리겠습니다. 세션 방식은 유저가 로그인하면 서버는 이 유저 정보를 세션에 저장하고, 발급된 세션 ID를 쿠키를 통해 클라이언트에게 전달합니다. 이후 유저 인증이 필요할 때마다 클라이언트에서는 쿠키에 담긴 세션 ID를 함께 전송하고, 서버는 이 세션 ID를 받아 인증을 허가하게 됩니다.
    다음으로 JWT는 Json Web Token의 약자로, 유저가 로그인하면 서버는 유저 데이터, 만료 시간 등을 포함하는 토큰을 생성해 클라이언트에 전달하고, 클라이언트는 받아온 토큰을 로컬 스토리지나 쿠키에 저장하고, 유저 인증이 필요한 요청에는 해당 토큰을 보내 서버가 이를 검증하는 단계를 거칩니다.
    이 둘의 큰 차이는 서버 부하에 있습니다. 세션은 서버에서 세션 정보를 저장하고 있기 때문에 서버 부하가 증가할 수 있는 단점이 있습니다. 반면, JWT 방식은 stateless이기 때문에 서버에 유저 세션 정보를 저장하지 않아 부하가 적습니다.
    저는 이전에 회사에서 했던 프로젝트에서 JWT를 이용해 역할 기반 접근 권한을 줬던 경험이 있습니다.