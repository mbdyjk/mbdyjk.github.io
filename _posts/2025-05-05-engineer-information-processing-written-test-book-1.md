---
title: "정보처리기사 필기 책 1과목 개념문제 풀기 및 개념 정리"
date: 2025-05-05
categories: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
tags: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
---

# 정보처리기사 실기 책 1편

## 1. 소프트웨어 설계

### 1) 소프트웨어 생명 주기
- 폭포수 모형: 고전적 생명 주기 모형, 선형 순차적 모델
- 나선형 모형: 점진적 모형, 지속적 발전, 위험관리 중심, 개발과정의 반복
- 에자일 모형: 프로세스와 도구, 계획 보다는 상호작용에 포커스, 결과물과 고객의 피드백 중시, 문서 중요도 낮음 
  - 에자일 모형의 예시: 스크럼, XP, 칸반, 기능중심 개발, Lean, Crystal 등

### 2) 스크럼 기법
- 스크럼: 스스로 팀 구성, 스스로 해결, 요구사항에 우선순위를 부여한 기능 목록(백로그) 작성, 스프린트(개발주기) 2~4주 진행, 회고
스프린트 계획 회의 -> 스프린트 수행 -> 일일 스크럼 회의(반복) -> 스프린트 검토 회의 -> 스프린트 회고

### 3) XP(eXtreme Programming) 기법
- 구조적 방법론이 아닌, 애자일 개발 방법론 기반 => 소통과 단순성, 고객의 적극적 참여에 가치, 릴리즈를 짧게 하고 고객을 참여시켜 고객의 요구사항(User Story) 반영 확인이 빠르게 이루어짐
- 주요 실천 방법: Pair Programming, Collective Ownership, Test-driven Development, Whole Team, Continuous Integration, Design Improvement, Refactoring, Small Releases

### 4) 현행 시스템 파악
- 절차
  - 1단계: 시스템 구성 파악(기간업무/지원업무), 시스템 기능 파악(계층형 표시), 시스템 인터페이스 파악(주고받는 데이터, 통신규약, 연계 유형, 주기)
  - 2단계: 아키텍처 구성 파악(레이어별로 어떤 기술 요소가 사용되었는지 구성도 작성, 컴포넌트), 소프트웨어 구성 파악(소프트웨어의 제품명, 용도, 라이센스 명시 - 상용 소프트웨어)
  - 3단계: 하드웨어 구성 파악(서버 스펙, 이중화 여부 파악 - 대기 서버에서도 동일하게 복제하여 관리), 네트워크 구성 파악(서버들의 물리적 위치 관계 파악, 보안 취약성 분석 가능)

### 5) 개발 기술 환경 파악
- OS: 시스템 자원 효율적 관리, 사용자에게 컴퓨터 작업 환경 제공
=> 가용성(주어진 시점에서 요구사항에 따라 운영될 수 있는지;장시간 운영, 메모리 누수, 보안 허점, 결함 대비), 성능, 기술 지원, 주변 기기, 구축 비용(하드웨어, 라이센스, 유지관리 => 총 소유 비용)
- DBMS: 가용성, 성능, 기술 지원, 상호 호환성(설치 가능 운영체제 종류), 구축 비용 고려
- WAS: **동적인 컨텐츠 처리**를 위해 사용되는 미들웨어(웹 서버와 DB 서버 간의 중간 계층 역할), HTTP 요청을 받아 비즈니스 로직 처리, 동적 컨텐츠(HTML, JSON 등)를 생성해 클라이어트로 전송
=> 가용성, 성능, 기술 지원, 구축 비용

### 6) 요구사항 정의
- 요구사항 개발 프로세스: 도출->분석->명세->확인
- 도출: 프로토타이핑(프로로타입을 통해 요구 분석 수행, 명세서 산출), 유스케이스(사용자의 요구사항을 기능단위로 표현)
- 분석: 명확하지 않은 부분 발견 및 타당성 조사, 자료 흐름도/자료 사전 등 사용
- 명세: 모델 작성 및 문서화, 정형 명세(수학적 원리/모델 기반, 간결하고 일관성), 비정형 명세(상태/기능/객체 중심, 자연어 기반으로 이해가 쉬움)
- 확인(검증): 명세 내용을 바탕으로 이해관계자들이 점검

### 7) 요구사항 분석
- 개발의 실제적인 첫 단계, 요구사항 추출 및 문서화
- DFD(자료 흐름도): 도형 중심 기술, process(원/둥근 사각형, 처리 과정), data flow(화살표, 자료 이동, 연관 관계), data store(작대기 두개, 저장소), 단말(사각형, 시스템과 교신하는 외부 개체, 정보의 생산자/소비자 역할)
- DD(자료 사전): 자료 흐름도 구체화, 메타데이터로 설명, =(자료 정의). +(자료 연결), ()(자료 생략), [](자료 선택), {}(자료 반복), **(자료 설명)

### 8) 요구사항 분석 CASE와 HIPO
- CASE(자동화 도구): 요구사항 자동 분석, 분석 명세서 기술
  - SADT(SoftTech): **블록 다이어그램** 채택
  - SREM(TRW): 실시간 처리 소프트웨어 시스템 타겟, RSL(요소, 속성, 관계, 구조 기술하는 요구사항 기술 언어) 사용, REVS로 RSL로 기술된 요구사항들 자동 분석하여 명세서 출력
  - PSL/PSA(미시간 대학): PSL을 요구사항 기술 언어로 사용, PSA로 자동 분석
  - TAGS: 통합 자동화도구, IORL로 요구사항 명세 언어 사용
- HIPO: 시스템 분석, 설계, 문서화에 사용
  입력/처리/출력 표현, 하향식, 기호/도표 사용, 의존 관계 표현, 변경과 유지보수에 용이
  - HIPO Chart: 가시적 도표(전체 기능을 계층 구조도로 표시), 총체적 도표(기능에 대한 입력/처리/출력 정보로 제공하는 도표), 세부적 도표(총체적 도표의 기본 요소들을 상세하게 기술)

### 9) UML(Unified Modeling Language)
- UML: 개발자와 고객 또는 개발자 간 **공통된 표현법**을 사용하기 위해 표준화한 객체지향 모델링 언어, 6개의 구조 다이어그램, 7개의 행위 다이어그램
  - 사물: 구조 사물(개념적 요소), 행동 사물(행위), 그룹 사물, 주해 사물(부가 설명)
  - 관계
    1) 연관 관계(Association): 화살표, 양방향 관계의 경우 실선, 연관에 참여하는 객체 개수 표시
    2) 의존 관계(Dependency): 점선 화살표, 연관 관계가 특정 조건에서만 유지
    3) 집합 관계(Aggregation): 빈 마름모(상위쪽), 포함 관계+서로 독립적
    4) 포함 관계(Composition): 채워진 마름모, 포함 관계+독립될 수 없고 생명주기 함께 함
    5) 일반화 관계(Generalization): 빈 화살표, 일반적인 개념을 상위, 구체적인 개념을 하위
    6) 실체화 단계(Realization): 빈 점선 화살표, 동작 기준 그룹화
  - 다이어그램
    1) 구조적 다이어그램(정적 모델링): 클래스 다이어그램, 객체 다이어그램(럼바우 객체 모델링), 컴포넌트 다이어그램(구현 모듈), 배치 다이어그램(물리적 요소들의 위치), 복합체 구조 다이어그램, 패키지 다이어그램
    2) 행위 다이어그램(동적 모델링): 유스케이스 다이어그램(사용자와 사용 사례로 구성), 순차/시퀀스 다이어그램(상호작용하는 대상의 메시지 표현), 커뮤니케이션 다이어그램(순차 다이어그램+객체들 간의 연관까지 표현), 상태 다이어그램(객체가 자신이 속한 클래스의 상태 변화/다른 객체와의 상호 작용에 따라 어떻게 상태가 변하는지 표현, 럼바우 동적 모델링), 활동 다이어그램(처리 흐름), 상호작용 개요 다이어그램, 타이밍 다이어그램(객체 상태 변화와 시간 제약 표현)
- 스테레오 타입: UML 기본 기능 외에 추가 기능 표현
  길러멧(겹화살괄호) 사이에 표현할 형태 기술
  : include, extend, interface, exception, constructor

### 10) 주요 UML 다이어그램
- 유스케이스 다이어그램 구성 요소: 시스템/시스템 범위(사각형으로 묶어 내부 범위 표시), 액터(주액터: 사용자, 시스템 사용 대상, 부액터: 주액터 목적 달성을 위해 서비스를 제공하는 외부 시스템, 조직/기관), 유스케이스, 관계
- 클래스 다이어그램 구성 요소: 클래스, 제약 조건, 관계, 접근 제어자
- 순차 다이어그램 구성 요소: 액터, 객체, 생명선(객체가 메모리에 존재하는 기간), 실행 상자(구동 중임을 표현), 메시지

### 11) 사용자 인터페이스
- UI 개발 시스템 기능: 사용자 입력 검증, 에러 처리/메시지 표시, 도움과 프롬프트(지시문) 제공
- 모바일 기기에서 사용하는 NUI 인터페이스 종류: Tap(누르기), Double Tap, Drag, Pan(누른채 계속 움직임), Press, Flick(빠르게 스크롤), Pinch(두 손가락으로 넓히기/좁히기)

### 12) UI 표준 및 지침
- 웹의 3요소: 웹 표준, 웹 접근성, 웹 호환성
- 웹 표준: 호환성, 접근성, 유지 보수성, 미래 확장성 보장
  - 구조: HTML(시멘틱 태그 사용->SEO, 접근성 향상)
  - 표현: CSS(미디어쿼리,flexbox/grid->일관된 스타일링)
  - 동작: JavaScript(사용자 입력 처리->표준화된 api로 호환성 유지)
  - 접근성: WCAG(이미지 대체 텍스트, 키보드 네비게이션->포용성)
  - 프로토콜: HTTP/HTTPS(데이터 전송 프로토콜->데이터 암호화)0
- 네비게이션 요소: 메뉴, 링크, 이미지 맵(그림에 하이퍼링크), 사이트 맵(사이트 전체 구조를 트리 형태로), 사이트 메뉴 바(메뉴 모음, 계층적), 네비게이션바(메뉴 모음), 디렉터리(카테고리별 표시)

### 13) UI 설계 도구
- 와이어프레임: 영역 구분, 배치를 화면 단위로 설계 - PPT, 스케치, 일러스트, 포토샵
- 목업: 시각적으로 실제 화면과 유사하게 구성 요소 배치 - 파워/발사믹 목업
- 스토리보드: 와이어프레임에 컨텐츠 설명, 페이지 간 이동 흐름 추가 - PPT, 스케치, Axure
- 프로토타입: 인터렉션을 적용한, 테스트가 가능한 동적인 형태 모형 - HTML/CSS, Axure
- 유스케이스: 사용자 측면의 요구사항을 기능 단위로 표시

### 14) UI 요구사항 확인
- 목표 정의: 개별적, 다수 대상, 사용자 리서치 전 인터뷰 진행
- 활동 사항 정의
- UI 요구사항 작성: 요구사항 요소 확인->정황 시나리오 작성(요구사항 정의에 사용되는 초기 시나리오, 사용자가 수행하는 과정을 이야기 형식으로 표현)

### 15) 품질 요구사항
- ISO/IEC 9126: 품질 특성과 평가를 위한 국제 표준
- ISO/IEC 12119: 테스트 절차가 포함된 표준
- ISO/IEC 14598: 개발자, 구매자, 평가자 별로 수행해야 할 제품 평가 활동 규정
- ISO/IEC 25010: 호환성과 보완성 강화
- 기능성(적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성), 신뢰성(성숙성, 고장 허용성, 회복성), 사용성(이해성, 학습성, 운용성, 친밀성), 효율성(시간/자원), 유지 보수성(분석성, 변경성, 안정성, 시험성), 이식성(적용성, 설치성, 대체성, 공존성)

### 16) UI 프로토타입 제작 및 검토
- 프로토타입: 요구사항의 테스트 가능한 동적인 구현체, 유스케이스가 텍스트로 흐름을 설명한다면 프로토타입은 화면단위로 순서 기술
- 특징: 일부 핵심 기능 포함, 지속적 개선/보완, 실제 사용자 테스트, 작업 시간/자원 소모 큼, 개발 시간 단축 및 개발 전 오류 발견, 맞게 해석했는지 검증을 위해 필요, 프로젝트 실제 분석 작업이 완료되기 이전에에 진행(확인을 완료 후 분석)

### 17) UI 설계서 작성
- 수정될 때마다 버전 0.1씩 높임, 사이트 맵 작성(사이트에 표시할 컨텐츠를 메뉴별로 구분하여 설계, 트리 형태), 프로세스 정의서 작성, 화면 설계(와이어프레임->스토리보드로 설계에 대한 설명, 흐름 추가)

### 18) 유용성 평가
- 완성된 모형과의 차이가 작은 UI 제작
  => 의도 파악, 순서 세분화, 다양한 방법/친숙한 방법이 되도록, 순서대로 실행, 간결하도록, 변화 직접 파악할 수 있도록, 의도와 결과 간 유사 정도를 쉽게 파악할 수 있도록

### 19) UI 상세 설계
- UI 시나리오 문서: 인터렉션 디자이너가 트리 구조, flow Chart로 작성, 사용자 태스크에 초점, 공통 ui 요소/인터렉션을 일반 규칙으로 정의, 주요 키 위치와 기능 설명, 기본 스크린 레이아웃(모든 화면 공통), 공통 단위 태스크 흐름(기능들에 공통적으로 사용되는 내용 - 삭제, 검색, 매너모드), 케이스 문서(공통 시스템 동작)
- 형판, 형틀 -> 템플릿

### 20) HCI/UX/감성공학
- HCI: 사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 연구 -> 최적의 UX
- UX: 사용자가 서비스를 이용하면서 느끼게 되는 경험(주관성, 정황성, 총체성)
- 감성 공학: 사용자 감성에 맞는 설계(기반 기술, 구현 기술, 응용 기술)

### 21) 소프트웨어 아키텍처의 설계
- 상위 설계: 아키텍처 설계(전체 구조, DB/인터페이스)
- 하위 설계: 모듈 설계(내부 구조, 컴포넌트/자료구조/알고리즘)
- 기본 원리
  - 모듈화
  - 추상화: 포괄적인 개념 설계 후 세분화(과정 추상화, 데이터 추상화, 제어 추상화) - 다이어그램 생각
  - 단계적 분해: 하항식 설계 전략, 상위 개념->하위 개념 구체화
  - 정보 은닉: 커뮤니케이션이 필요한 정보만 인터페이스로 주고받음
  => 독립적 수행, 수정/테스트/유지보수 용이
- 소프트웨어 아키텍처 설계 과정: 설계 목표 설정 -> 시스템 타입 결정 ->
  아키텍처 패턴(스타일) 적용 -> 서브시스템 구체화 -> 검토
- 시스템 타입: 대화형 시스템/이벤트 중심 시스템(외부 상태 변화)/변환형 시스템(데이터 입력에 따른 결과 출력)/객체 영속성 시스템(DB 사용)
- 협약에 의한 설계: 클래스에 대한 여러 가정 공유를 위한 명세, 선행 조건/결과 조건/불변 조건

### 22) 아키텍처 패턴
- 레이어 패턴: 시스템을 계층으로 구분하여 구성, 하위 계층은 상위 계층에 대한 서비스 제공자,
  상호작용이 마주보는 두 개의 계층 사이에서만 이루어져 변경 작업에 용이, OSI 참조 모델
  
  * OSI 참조 모델: 네트워크 프로토콜을 계층별로 구분한 모델
- 클라이언트-서버 패턴: 서로 독립적
- 파이프-필터 패턴: 데이터 스트림 절차를 필터 컴포넌트로 캡슐화, 파이프를 통해 전송,
  데이터 변환/버퍼링/동기화 등에 사용, 오버헤드 발생, UNIX의 Shell
- MVC 패턴: 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합
- 마스터-슬레이브 패턴: 마스터 컴포넌트는 동일한 구조의 슬레이브 컴포넌트로 분할하여 작업 결과를 돌려받음,
  장애 허용 시스템과 병렬 컴퓨팅 시스템, 실시간 시스템에서 활용, 슬레이브 컴포넌트의 일부가 문제가 있어도 전체적으로는 정상 동작
- 브로커 패턴: 사용자가 원하는 서비스를 브로커 컴포넌트에 요청하여 요청에 맞는 컴포넌트나 사용자 연결, 분산 환경 시스템
- 피어 투 피어 패턴: 각 피어가 서버/클라이언트가 될 수 있고, 멀티스레딩 방식 사용
- 이벤트-버스 패턴: 소스, 리스너, 채널, 버스
- 블랙보드 패턴: 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근 가능, 음성 인식/차량 식별/신호 해석
- 인터프리터 패턴: 코드의 각 라인을 수행하는 방법 지정, 특정 언어로 작성된 코드 해석 컴포넌트

### 23) 객체지향
- 데이터를 객체화하여 프로그램 구성 => 재사용성, 유지보수성, 확장성 높임
- 객체: 데이터/함수를 캡슐화한 모듈, 객체가 가질 수 있는 조건: 상태, 행위 지시 명령: 메시지
- 클래스: 공통된 속성과 연산을 갖는 객체의 집합, 데이터 추상화, 슈퍼 클래스-서브 클래스
- 캡슐화: 세부 내용 정보 은닉 효과 -> 외부 모듈의 변경으로 인한 영향 적음, 재사용성 높아짐
- 상속: 소프트웨어 재사용성을 높임, 다중 상속(두 개 이상의 부모 클래스)
- 다형성: 하나의 메시지에 대해 여러 형태의 응답 존재
  - 오버로딩: 메서드의 이름은 같지만, 매개변수의 자료형과 개수를 달리해 여러 기능 정의
  - 오버라이딩: 상위 클래스에서 정의한 메서드를 재정의하여 자식에서 사용

### 24) 객체지향 분석 및 설계
- 럼바우 방법(객체 모델링 기법,OMT): 객체(정보) 모델링(객체 다이어그램)->동적 모델링(상태 다이어그램)->기능 모델링(자료 흐름도) => 객동기!
- Booch 방법: 미시적/거시적 개발 프로세스 모두 사용
- Jacobson 방법: Use Case 강조 => JUC!
- Coad와 Yourdon 방법: E-R 다이어그램을 사용하여 모델링 => CYER!
- Wirfs-Brock 방법: 분석과 설계 간 구분이 없고, 고객 명세서를 평가해 설계 작업까지 연속적 수행
- 객체지향 설계원칙: 단일 책임 원칙(SRP), 개방 폐쇄 원칙(OCP, 기존 코드 변경 없이 기능 추가),
  리스코프 치환 원칙(LSP, 자식 클래스는 부모 클래스에 정의된 행위를 수행할 수 있어야 함, **확장**만 수행),
  인터페이스 분리 원칙(ISP, 사용하지 않는 인터페이스와 의존 관계/영향을 받지 않아야 함),
  의존 역전 원칙(DIP, 객체들 간의 의존 관계가 성립될 때 **추상성이 높은 클래스와 의존 관계**를 맺어야 함)
  =>SOLID 원칙

### 25) 모듈
- 독립성: 결합도(Coupling)와 응집도(Cohesion)에 의해 측정
- 결합도(낮은순): 모듈 간 의존도
  - 자료 결합도: **단순 데이터**(기본 타입 매개변수) 데이터 전달
  - 스탬프 결합도: 배열/객체나 레코드 등의 **자료 구조** 전달
  - 제어 결합도: **제어 신호**로 통신/제어 요소 전달, 처리 기능이 두 모듈에 분리, 권리 전도 현상 발생
  - 외부 결합도: 외부 모듈에서 다른 모듈에 선언한 데이터 접근
  - 공통 결합도: 공유되는 공통 데이터 영역을 여러 모듈이 사용
  - 내용 결합도: 한 모듈이 다른 모듈의 내부 기능/자료를 직접 참조
- 응집도(강한순): 내부 요소들 간의 관련성
  - 기능적 응집도: 모든 기능 요소들이 단일 문제와 연관
  - 순차적 응집도: 하나의 활동의 출력이 다른 활동의 입력으로 사용
  - 교환(통신)적 응집도: 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모임
  - 절차적 응집도: 모듈이 다수 관련 기능을 가질 때 구성 요소들이 순차적으로 수행
  - 시간적 응집도: 특정 시간에 처리되는 기능들을 모아 하나의 모듈로 만듬
  - 논리적 응집도: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 모듈을 만듬
  - 우연적 응집도: 관련없는 요소로만 구성
  => 기순통절시논우
- 팬인: 어떤 모듈을 제어하는 모듈의 수 -> 높을 경우 재사용성 높음, 단일 장애점 발생 가능성
- 팬아웃: 모듈에 의해 제어되는 모듈의 수 -> 높을 경우 단순화 필요
- N-S 차트: 논리 기술에 중점, GOTO/화살표 사용하지 않음,
  조건이 복합되어 있는 곳의 처리 명확히 식별, 단일 입구/단일 출구

### 26) 공통 모듈
- 재사용 규모에 따른 분류: 함수와 객체, 컴포넌트(자체 수정 없이 인터페이스를 통해 통신), 애플리케이션

### 27) 코드
-> 식별, 분류, 배열, 표준화, 간소화 기능
- 순차 코드
- 블록 코드: 공통성 있는 것끼리 블록으로 구분, 이후 일련번호
- 10진 코드: 10진 분할하여 세분화
- 그룹 분류 코드: 대분류-중분류-소분류, 분류 안에서 일련번호
- 연상 코드: 명칭이나 약호와 관계있는 숫자/문자/기호 사용하여 코드 부여
- 표의 숫자 코드: 성질을 그대로 코드에 적용, 유효 숫자 코드
- 합성 코드: 2개 이상의 코드 조합

### 28) 디자인 패턴
: 세부 구현 방안 설계시 참조할 수 있는 전형적인 해결 방식
GoF가 체계화, 생성 패턴 5개/구조 패턴 7개/행위 패턴 11개 총 23개
- 특징: 범용적, 생산성 높임, 검증된 구조 재사용으로 개발 시간/비용 절약, 초기 투자 비용 부담, 객체지향 기반에 적합
- 생성 패턴: 객체 생성과 참조 과정을 캡슐화->유연성을 높임
  - 추상 팩토리: 인터페이스를 통해 객체들의 그룹으로 추상적 표현, 연관된 서브 클래스를 묶어 한번에 교체 가능
  - 빌더: 인스턴스 조합
  - 팩토리 메서드: **객체 생성을 서브 클래스에서 처리**하도록 분리하여 캡슐화, 상위 클래스에서 인터페이스만 정의
  - 프로토타입: **원본 객체를 복제**하는 방법으로 객체 생성
  - 싱글톤: 클래스 내에서 인스턴스가 하나임을 보장
- 구조 패턴: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 함
  - 어댑터: 기존 클래스의 인터페이스가 호환되지 않을 때 다른 클래스가 이용할 수 있도록 변환
  - 브리지: **기능과 구현을 별도 클래스로 구현**하여 서로가 독립적 확장 가능
  - 컴포지트: **복합 객체와 단일 객체를 구분없이 다룸**, 트리 구조
  - 데코레이터: 객체 간 결합을 통해 능동적으로 기능들 확장, 덧붙이는 방식
  - 퍼싸드: 복잡한 서브 클래스들을 피해 Wrapper 객체를 두고 상위 인터페이스 구성
  - 플라이웨이트: 인스턴스를 필요할 때마다 생성하는 것이 아닌 가능한 공유해서 사용하여 메모리 절약
  - 프록시: 접근이 어려운 객체와 연결하려는 객체 사이 인터페이스 역할 수행, 네트워크 연결/메모리 객체 접근
- 행위 패턴: 상호 작용/책임 분배 방법 정의
  - 책임 연쇄: 요청을 처리할 수 있는 객체들이 둘 이상 체인으로 묶여 책임을 넘길 수 있음
  - 커맨드: 요청을 객체 형태로 캡슐화하여 재이용/취소할 수 있도록 요청에 필요한 정보 저장(추상 클래스/구체 클래스)
  - 인터프리터: 언어의 문법 표현 정의, SQL/통신 프로토콜 개발
  - 반복자: 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스 사용
  - 중재자: 복잡한 상호작용을 **캡슐화**하여 객체로 정의, 의존성을 줄여 결합도를 감소
  - 메멘토: **특정 시점에서의 객체 내부 상태**를 객체화하여, 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능
  - 옵저버: 객체의 상태가 변화하면 상속되어 있는 다른 객체들에게 변화된 상태 전달->**이벤트**
  - 상태: 객체의 상태에 따라 동일한 동작을 다르게 처리
  - 전략: **동일한 계열의 알고리즘들을 캡슐화**하여 상호 교환할 수 있게 정의, 클라이언트는 선택하여 사용 가능
  - 템플릿 메서드: 상위 클래스에서 골격 정의, 하위 클래스에서 세부 처리 구체화
  - 방문자: 처리 기능을 분리하여 별도의 클래스로 구성, 클래스를 방문하여 기능 수행

### 29) 시스템 인터페이스 요구사항 분석
- 시스템 인터페이스: 독립적으로 떨어져 있는 시스템들끼리 서로 연동하여 상호작용하기 위한 접속 방법/규칙
- 요구사항 명세서 구성: 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 송신 데이터, 연계 방식, 인터페이스 주기, 기타 고려사항 => 인터페이스 다이어그램 생각!
- 기능적 요구사항/비기능적 요구사항(개발 과정에서 지켜져야 하는 제약 사항)
- 요구사항 분석: 분해가 필요한 경우 세분화, 누락된 요구사항/제한사항 추가, 우선순위 부여
- 절차: 요구사항 선별->요구사항 관련 자료 준비->요구사항 분류->요구사항 분석 및 명세허 구체화->요구사항 명세서 공유

### 30) 인터페이스 요구사항 검증
- 요구사항 검증 과정: 요구 사항 검토 계획 수립->검토 및 오류 수정->베이스라인 설정
- 검토 계획 수립: 검토 참여자들에게 방식과 자료와 일정 전달
- 검토 및 오류 수정: 오류 목록과 시정 조치서 작성
- 베이스라인 설정: 인터페이스 요구사항을 공식적으로 승인받음
- 검증 방법: 동료검토(작성자가 명세서 내용을 직접 설명하고 동료들이 들으며 결함 발견), 워크스루(요구사항 명세서를 미리 배포하여 사전 검토 후 결함 발견), 인스펙션(작성자 제외 다른 검토 전문가들이 명세서 확인하며 결함 발견), 프로토타이핑, 테스트 설계, CASE 도구 활용(요구사항의 추적과 일관성 검토)

### 31) 인터페이스 시스템 식별
: 시스템 사이 인터페이스 식별한 다음, 사용되는 송/수신 시스템 구분
- 시스템 레벨: 상위 시스템에 따라 레벨로 구분, 기업 내부 체계에 따라 정의
- 개발 시스템 식별: 개발 시스템의 상세 식별 정보 정의 및 목록 작성
- 내외부 시스템 식별: 내외부 시스템의 상세 식별 정보 정의 및 목록 작성
- 내외부 시스템 환경 및 관리 주체 식별: 실제 운용 환경과 하드웨어 관리 주체 확인
- 내외부 시스템 네트워크 연결 정보 식별: 로그인 및 DB 정보 확인
- 인터페이스 식별: 요구사항 **명세서와 목록**을 기반으로 시스템 식별
- 인터페이스 **시스템** 식별: 인터페이스에 **참여하는 시스템을 송신/수신 시스템으로 구분**하여 작성

### 32) 송수신 데이터 식별
- 식별 대상 데이터: 송수신 시스템 사이 교환되는 규격화된 데이터
  - 인터페이스 표준 항목: 송수신 시스템 연계에 필요한 데이터
    - 시스템 공통부: **연동시 필요한 정보**
    - 거래 공통부: **연동된 후** 데이터 처리에 필요한 정보(실물 관련)
  - 송수신 데이터 항목: 송수신 시스템 업무 수행에 사용하는 데이터
  - 공통 코드: 상태 및 오류 코드 등
- 데이터베이스 산출물: 교환 범위 식별과 송수신 데이터 식별에 필요, 테이블 정의서, 코드 정의서, ERD 등이 있음
- 코드성 데이터 항목에 대해 송수신 시스템 코드 정보 동일시 공통 코드 정보 확인, 다를시 각 코드 정보 확보

### 33) 인터페이스 방법 명세화
: 내외부 시스템이 연계하여 작동할 때 데이터를 주고받는 방법, 데이터 종류, 에러 처리 내용을 문서로 명확히 정리
- 시스템 연계 기술: DB Link, API, 연계 솔루션(EAI 서버-송수신 처리 및 모니터링 와 클라이언트 이용), Socket(통신을 위한 소켓 생성, 포트 할당), Web Service(WSDL-웹 서비스, UDDI-규격화된 비즈니스 업체 등록시 사용하는 XML 기반 규격, SOAP-통신규약)
- 인터페이스 통신 유형: 단방향/동기/비동기
- 인터페이스 처리 유형: 실시간/지연처리/배치(대량)
- 오류 발생 영역: 송신 시스템(데이터를 전송 형식에 맞게 변환하여 송신), 수신 시스템(연계 프로그램에서 처리할 수 있는 형식으로 변환하여 반영), 연계 서버(송수신 현황을 모니터링)

### 34) 시스템 인터페이스 설계서 작성
: 인터페이스 식별 및 명세 기술 -> 시스템 인터페이스 목록과 정의서 작성
- 시스템 인터페이스 목록: 연계업무, 송수신 시스템 정보, 연계 방식, 통신 유형
- 시스템 인터페이스 정의서: 송수신 시스템 간 데이터 저장소와 속성 작성, 기본 정보는 시스템 인터페이스 목록 참고
* 최대 처리 횟수: 단위 시간 당 처리될 수 있는 인터페이스 최대 수행 건수
* 데이터 크기: 1회 처리시 소요되는 데이터의 평균 및 최대 크기

### 35) 미들웨어 솔루션 명세
- 미들웨어: 서로 다른 환경(하드웨어, 프로토콜, 통신환경)을 연결하여 프로그램 간의, 또는 서버/클라이언트 간의 원만한 통신을 이루도록 서비스를 제공하는 역할 수행, 위치 투명성(시스템의 논리적 명칭으로 접근) 제공, 미들웨어 내부 동작은 별도의 응용 소프트웨어를 사용해 알 수 있음
- 종류
  - DB: 클라이언트에서 원격 데이터베이스와 연결하기 위한 미들웨어, 2 Tier 아키텍처, MS ODBC, 오라클 Glue 등
  - RPC(원격 프로시저 호출): **원격 프로시저를 로컬 프로시저처럼 호출**하는 방식의 미들웨어
  - MOM(메시지 지향 미들웨어): **메시지 기반** 비동기형 메시지 전달, 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기에 사용
  - TP-Monitor(트랜잭션 처리 모니터): **온라인 트랜잭션 업무에서 처리 및 감시** 담당 미들웨어, 사용자 수가 증가해도 빠른 응답속도 유지(예약 등 업무)
  - ORB(객체 요청 브로커): **객체 지향 미들웨어**, CORBA 표준 스펙 구현
  - WAS(웹 어플레케이션 서버): **동적인 컨텐츠 처리**를 위한 미들웨어, 웹 환경 구현에 사용
- 미들웨어 솔루션 식별: 구매 관련 확인, 솔루션 목록 작성, 누락 확인
- 미들웨어 솔루션 명세서 작성: 제품안내 및 소개서 내용 검토, 기능 및 특징 검토, 제약사항 검토