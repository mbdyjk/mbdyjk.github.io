---
title: "정보처리기사 필기 책 2과목 개념문제 풀기 및 개념 정리"
date: 2025-05-07
categories: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
tags: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
---

# 정보처리기사 실기 책 2편

## 2. 소프트웨어 개발

### 36) 자료 구조
- 선형 구조
  - 배열
  - 선형 리스트
    - 연속 리스트: 기억 장소를 연속적으로 배정->이용 효율은 밀도가 1로서 좋음, 삽입/삭제시 자료 이동이 필요
    - 연결 리스트: 자료들을 임의의 공간에 기억시키고, 노드의 포인터를 이용해 서로 연결, 삽입/삭제에 용이, 포인터 부분이 필요해 공간 이용 효율이 좋지 않음, 연결을 위한 포인터 찾는 시간이 필요해 접근속도 느림, 중간 노드 연결이 끊어지면 다음 노드를 찾기 힘듬
  - 스택: 함수 호출 순서 제어, 인터럽트 처리, 수식 계산 및 표기법, 컴파일러 이용한 번역, 서브루틴 호출 및 복귀주소 저장, 재귀 호출, 전위/후위 표현 연산, 깊이 우선 탐색
    꽉 채워져있을 때 삽입시 오버플로, 비어있을 때 삭제시 언더플로
    M: 스택 크기, Top: 스택 포인터(최근 자료), Bottom
  - 큐: 운영체제 작업 스케줄링
    F: 가장 먼저 삽입된 자료->삭제, R: 가장 마지막에 삽입된 자료->추가
  - 데크: 스택+큐 특징, 양쪽에서 삽입/삭제 가능
- 비선형 구조(정점(vertex)과 연결하는 간선(edge)으로 구성)
  - 트리: 사이클이 없는 계층적 구조
  - 그래프: 방향 그래프/무방향 그래프 - 간선 수는 그림 그려서

### 37) 트리
- node와 link로 구성된 그래프의 특수 형태
- 개념: degree(차수, 뻗어나온 가지 수), 단말 노드, 트리의 차수(최대 차수)
- **운행법**: Preorder(root->left->right), Inorder(left->root->right), Postorder(left->right->root)
  풀이는 서브트리 단위로 묶어서 접근
- **수식 표기법**: 전위(연산자->left->right;Preorder 방향), 중위(left->연산자->right;Inorder 방향), 후위(left->right->연산자;Postorder 방향)
  - Infix는 스택을 이용해 처리하는 Postfix나 Prefix로 바꾸어 처리한다.
  => 변환방법: 연산순위에 따라 괄호로 묶음 -> 전위 표기법의 경우 연산자를 앞, 후위 표시법의 경우 연산자를 뒤로 보냄->괄호 제거
  - 반대로 Postfix나 Prefix로 표기된 수식을 Infix로 변환하는 방법
  => 피연산자 두개와 후위 표시법의 경우오른쪽 연산자를 괄호로 묶음 -> 피연산자 가운데로 이동

### 38) 정렬
- 삽입 정렬: 처음부터 순서대로 비교하여 나열, **n 번째 키를** n-1개 키와 비교하여 **알맞은 순서에 삽입**
  => 평균과 최악 모두 수행시간 복잡도: 평균과 최악 모두 O(n2)
- 쉘 정렬: 삽입 정렬 + **매개변수** 값으로 서브파일을 구성해 정렬, 부분 정렬되어 있는 경우 유리
  => 평균 수행시간 복잡도: O(n1.5), 최악 수행시간 복잡도: O(n2)
- 선택 정렬: **처음 레코드을 기준으로 하여 끝 레코드까지 최소값**을 찾아 첫 번째 레코드에 위치, 이후에도 반복
  => 평균과 최악 모두 수행시간 복잡도: O(n2)
- 버블 정렬: **인접한 두 레코드 키 값을 비교**하여 서로 교환
  => 평균과 최악 모두 수행시간 복잡도: O(n2)
- 퀵 정렬: **하나의 파일을 부분적으로 나누어** 가며 정렬, 정렬 방식 중에 가장 빠름, 분할과 정복(->분류)을 통해 정렬
  => 평균 수행시간 복잡도: O(nlog2n), 최악 수행시간 복잡도: O(n2)
- 힙 정렬: **전이진트리**를 이용한 정렬 방식, 노드의 **역순**으로 가서 자식 노드와 부모 노드를 **큰 값을 위로** 올림
  => 평균과 최악 모두 수행시간 복잡도: O(nlog2n)
- 2-way 합병 정렬: 이미 정렬된 두 개의 파일을 한 개의 파일로 합쳐 정렬, **두 개씩 내부에서 묶은 후** 정렬, 이를 반복
  => 평균과 최악 모두 수행시간 복잡도: O(nlog2n)
- 기수 정렬: 큐를 이용하여 자릿수별로 정렬, 버킷에 분배하였다고 순서대로 꺼내어 정렬
  => 평균과 최악 모두 수행시간 복잡도: O(dn)

### 39) 검색 - 이분 검색/해싱
- 이분 검색(Binary Search): 전체 파일을 두 개의 서브파일로 분리, 순서화된 파일 대상, 중간 레코드 key 값과 비교하며 검색, M = (F+L)/2 반복
- 해싱: 해시 테이블이라는 기억 공간을 할당하고, 해시 함수를 이용하여 데이터를 고유한 키에 매핑하여 저장 및 검색 수행
  - 해시 테이블: 버킷들로 구성된 기억 공간
  - 해싱 함수
    - 제산법: 레코드 키를 **해시표의 크기보다 큰 수 중 가장 작은 소수**로 나눈 나머지를 홈 주소로 삼는 방식
    - 제곱법: 레코드 키 값을 **제곱한 후 그 중간 부분 값**을 홈 주소로 삼는 방식
    - 폴딩법: 레코드 **키 값을 나눈 후 각 부분의 값을 더하거나 XOR한 값**을 홈 주소로 삼는 방식
    - 기수 변환법: 키 숫자 진수를 **다른 진수로 변환시켜 주소 크기를 초과한 자릿수는 절단**하고, 범위에 맞게 조정하는 방식
    - 대수적 코딩법: 키를 이루는 **각 자리 비트 수를 다항식 계수로 간주**하고, 다항식을 해시표 크기에 의해 정의된 다항식으로 얻은 나머지 다항식 계수를 홈 주소로 삼는 방식
    - 숫자 분석법: 키 값의 **숫자 분포를 분석해 비교적 고른 자리**를 택해서 홈 주소로 삼는 방식
    - 무작위법: **난수** 값을 홈 주소로 삼는 방식

### 40) 데이터베이스 개요
- 데이터저장소: 데이터를 논리적인 구조로 조직화(논리)하거나 물리적인 공간(물리)에 구축한 것 -> 데이터베이스 구축 과정과 동일
- 데이터베이스: 통합된 데이터(중복 배제), 저장된 데이터(컴퓨터 접근), 운영 데이터(고유 업무 수행에 반드시 필요), 공용 데이터(공동 소유 및 유지)
- DBMS
  - **정의** 기능: 타입과 구조에 대한 정의, 이용 방식, 제약 조건 명시
  - **조작** 기능: 삽입, 삭제, 갱신 등을 처리하기 위한 인터페이스 수단 제공
  - **제어** 기능: 무결성, 보안 및 권한 검사, 병행 제어
  - 장점: 종속성과 중복성의 배제
  - 단점: 전산화 비용 증가, 과부하, 예비/회복 어려움
- 스키마
  - DB 구조와 제약 조건에 관한 명세 기술 메타데이터 집합
    - 외부 스키마: 개인의 입장에서 필요로 하는 DB 논리적 구조 정의
    - 개념 스키마: DB 전체에 관한 논리 구조, 하나만 존재
    - 내부 스키마: 물리적 저장장치 입장에서 본 데이터베이스 구조, 저장될 레코드 형식 및 순서 정의 

### 41) 데이터 입출력
- 데이터 입출력을 위해 SQL(관계형 데이터베이스 지원 언어) 사용 -> Data Mapping(SQL Mapping;코드 내에 직접 sql 입력하여 dbms 데이터 접속, ORM;객체와 DB 데이터 연결)
- SQL 구분: DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어) -> DBMS 기능 참고
- 연산 단위: Transaction(TCL 명령어 사용; commit, rollback, savepoint 존재)

### 42) 절차형 SQL
: DB 전용 프로그래밍, 단일 SQL문으로 처리하기 어려운 연속적인 작업 처리에 적합,
DBMS 엔진에서 직접 실행되므로 입출력 패킷이 적음, BEGIN~END 형식으로 작성되는 Block 구조
- 종류: 프로시저(미리 저장한 작업 수행), 트리거(데이터 입력, 갱신, 삭제 등 이벤트가 발생할 때마다 관련 작업 자동 수행), 사용자 정의 함수(return을 사용해 처리 결과 단일값으로 반환)
- 테스트/디버깅: SHOW 명령어를 통해 문제 확인/수정, 디버깅은 주석 처리
- 최적화: APM을 사용해 쿼리 선정, 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성

### 43) 단위 모듈 구현
- 단위 모듈: 하나의 동작을 수행하는 기능(단위 기능)을 모듈화, 독립적 컴파일 가능
- 단위 기능 명세서 작성: 추상화하여 명세화, 정보 은닉의 원리 고려
- 입출력 기능 구현: 단위 모듈 간 연동 또는 입출력 데이터 구현
- 알고리즘 구현: 모듈로 구현(디바이스 드라이버;하드웨어 주변장치, 네트워크, 파일;내부 데이터 구조 영역에 접근, 메모리;가상 메모리에 파일을 매핑/해제하고 프로세스 사이 통신, 프로세스;하나의 프로세스에서 다른 프로세스 생성)
- IPC: 모듈 간 통신 방식 구현하기 위한 인터페이스 집합
  - 대표 메서드: Shared Memory, Socket, Semaphores(공유 자원에 대한 접근 제어), Pipes&named Pipes(선입선출 메모리), Message Queueing

### 44) 단위 모듈 테스트(Unit Test)
- 화이트박스 테스트(소스 코드 오픈한 상태로 논리적 경로 테스트), 블랙박스 테스트(기능 작동 테스트)
- 테스트 케이스: 테스트 항목에 대한 명세서
  - 구성 요소(ISO/IED 29119-3 표준): 식별자, 테스트 항목, 입력 명세, 출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술
- 테스트 프로세스 5단계: 계획/제어 -> 분석/설계(구체화 및 작성) -> 구현/실행(조합 및 도구 이용하여 수행) -> 평가 -> 완료(이후 테스트를 위한 기록/저장)

### 45) 개발 지원 도구
- 통합 개발 환경(IDE): 코딩, 디버깅, 컴파일, 배포를 하나의 프로그램에서 처리하도록 제공하는 소프트웨어
  ex) Eclipse(크로스 플랫폼), Visual Studio, Xcode(Mac), Android Studio, IDEA(크로스 플랫폼)
- 빌드 도구: 소스 코드 파일들을 실행할 수 있는 제품 소프트웨어로 변환하는 과정(전처리 및 컴파일)
  ex) Ant(아파치 개발, 자바의 공식 빌드 도구, XML 기반, 자유도와 유연성이 높음), Maven(아파치 개발, 컴파일과 빌드 동시 수행, 의존성 설정), Gradle(안드로이드 스튜디오 공식 빌드 도구, 의존성 활용, 그루비 기반 빌드 스크립트)
- 협업 도구
  - 프로젝트/일정 관리: 구글 캘린터, 지라, 분더리스트, 트렐로
  - 정보 공유/커뮤니케이션: 슬랙, 잔디
  - 디자인: 스케치, 피그마, 제플린

### 46) 소프트웨어 패키징
: 모듈별로 생성한 실행파일들을 묶어 배포용 설치 파일을 만드는 것
개발자가 아닌 사용자 중심으로 진행, 모듈화 및 일반적인 배포 형태로 패키징
- 고려사항: 최소 시스템 환경 정의, Managed Service 형태로 제공, 내부 컨텐츠에 대한 암호화 및 보안 고려, 편의성을 위한 복잡성/비효율성 문제 고려, 적합한 암호화 알고리즘 적용
- 패키징 작업 순서: 기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 및 적용 시험 -> 패키징 변경 개선 -> 배포

### 47) 릴리즈 노트 작성
: **개발 과정에서 정리된 릴리즈 정보**를 고객과 공유하기 위한 문서
ex) 테스트 결과, 사양 준수 여부, 기능/내용/개선사항 + 버전 관리
- 추가 버전 작성: 베타 버전 출시, 긴급한 버그 수정, 자체 기능 향상, 사용자 요청 등 특수 상황
- 작성 순서: 모듈 식별 -> 릴리즈 정보 확인 -> 개요 작성 -> 영향도 체크 -> 정식 릴리즈 노트 작성 -> 추가 개선 항목 식별

### 48) 디지털 저작권 관리(DRM)
: 창작자가 가지는 배타적 독점적 권리
- 특징: 아날로그인 경우 디지털로 변환 후 drm 패키징 수행, 크기가 작은 경우 컨텐츠 요청 시점에서 패키징 수행, 크기가 큰 경우 미리 패키징하여 배포, 패키징 수행시 저작권자의 전자서명 포함, 라이센스 정보가 클리어링 하우스에 등록, 클리어링 하우스에 등록된 라이센스 정보를 통해 인증 및 권한 소유 여부 확인, 사용량 측정
- 패키저: 컨텐츠를 메타데이터와 함께 암호화하여 배포 가능한 형태로 묶음
- DRM 컨트롤러: 배포된 컨텐츠의 이용 권한 통제(소비자 프로그램)
- 보안 컨테이너: 컨텐츠 원본을 안전하게 유통하기 위한 전자 보안 장치(소비자 프로그램)
- DRM의 기술 요소: 암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증
  => 보안/정보정책/식별

### 49) 소프트웨어 설치 메뉴얼 작성
- 서문: 문서 이력, 설치 매뉴얼 주석, 설치 도구 구성(exe, dll, ini, chm 등), 설치 환경 체크 항목
- 기본 사항: 개요, 관련 파일, 아이콘, 삭제, 추가 정보
- 설치 매뉴얼 작성 방법: 설치 화면 및 ui, 이상 메시지 설명, 완료 및 결과, faq, 점검 사항, network 환경 및 보안, 고객 지원 방법, 준수 정보&제한 보증
- 설치 매뉴얼 작성 순서: 기능 식별 -> UI 분류 -> 설치/백업 파일 확인 -> Uninstall 절차 확인 -> 이상 Case 확인 -> 최종 매뉴얼 적용

### 50) 소프트웨어 사용자 매뉴얼 작성
- 특징: 제반 사항 모두 포함, 컴포넌트 단위로 작성, 컴포넌트 명세서와 구현 설계서를 토대로 작성
- 서문: 문서 이력, 사용자 매뉴얼 주석, 기록 보관 내용(소프트웨어 등록 정보)
- 기본 사항: 개요, 사용 환경, 관리, 모델/버전/기능/인터페이스 특징, 구동 환경
- 사용자 매뉴얼 작성 방법: 화면 및 UI, 주요 기능 분류, 응용 프로그램 및 설정, 장치 연동, 네트워크 환경, 프로필 안내, 고객 지원 방법, 준수 정보&제한 보증
- 사용자 매뉴얼 작성 순서: 작성 지침 정의->구성 요소 정의->구성 요소별 내용 작성->사용자 매뉴얼 검토

### 51) 소프트웨어 버전 등록
- 형상 관리(SCM): 개발 과정에서 변경사항 관리, 관리 항목에는 코드 뿐 아니라 계획, 분석서, 설계서, 지침서, 테스트 케이스 등이 포함, 기능으로 형상 식별, 버전 제어, 형상 통제/감사/기록이 있다.
  => 변경 사항/문제 추적, 진행 상황 파악, 배포본 관리, 협업에 유리
- 주요 기능: import(최초로 레포지토리에 파일 복사), checkout(파일 받아옴), checkin(파일 갱신), commit, update

### 52) 소프트웨어 버전 관리 도구
- 공유 폴더 방식: 로컬 컴퓨터 공유 폴더에 버전 관리 자료가 저장되어 관리
  ex) sccs/rcs(시간에 따른 파일 변화 과정 관리, 동시 수정 방지 및 결과 병합 및 변경 내용 추적 가능)/pvcs/qvcs 등
- 클라이언트/서버 방식: 중앙 시스템(서버)에 버전 관리 자료 저장 -> 모든 버전 관리는 서버에서 수행
  ex) cvs/svn/cvsnt/clear case/cmvd/perforce 등
- 분산 저장소 방식: 원격 저장소 + 개발자 pc 로컬 저장소에 함께 저장되어 관리
  ex) git, gnu arch, dcvs, plastic scm 등
- Subversion(SVN): CVS 개선한 클라이언트/서버 구조의 형상관리도구, 모든 개발 작업은 trunk 디렉토리에서 수행, 추가 작업은 branches 디렉토리 안에 별도 디렉토리를 만들어 작업 후 trunk 디렉토리와 병합, 커밋할 때마다 리비전 1씩 증가, 서버는 주로 unix 사용, import로 초기 소스 파일 저장소에 저장, export로 순수 소스 파일 서버에서 받아옴
- Git: 원격 저장소나 네트워크에 문제 있어도 작업 가능, snapshot으로 파일 변화 저장, fetch로 원격 저장소 변경 이력을 로컬 저장소로 가져와 반영

### 53) 빌드 자동화 도구
- Jenkins: 자바 기반 빌드 도구, 서블릿 컨테이너(클라이언트 요청 처리하는 서버의 프로그램)에서 실행되는 서버 기반 도구, 형상 관리 도구와 연동 가능, web gui 제공, 분산 빌드나 테스트 가능
- Gradle: Groovy 기반 빌드 도구, 안드로이드 앱 개발 환경에서 사용, DSL을 스크립트 언어로 사용, 실행할 처리 명령들을 모아 task로 만든 후 task 단위로 실행, 빌드 캐시 기능을 지원해 빌드 속도 향상

### 54) 애플리케이션 테스트
: 기능 수행 **검증**과 고객 요구 사항 만족 **확인**으로 이루어짐
- 소프트웨어 분류
  - 상용 소프트웨어: 공통 필요 기능 제공
    - 산업 범용 소프트웨어: 시스템 소프트웨어, 미들웨어, 응용 소프트웨어
    - 산업 특화 소프트웨어
  - 서비스 제공 소프트웨어: 특화 기능 제공
    - 신규 개발/기능 개선/추가 개발/시스템 통합 소프트웨어
- 테스트 필요성: 기존 오류 및 새 오류 예방, 신뢰도 향상, 많은 결함 발견 가능
- 기본 원리: 완벽한 소프트웨어 테스팅은 불가능, 특정 모듈에 집중(파레토 법칙;20% 코드에서 80% 결함 발견),
  살충제 패러독스(테스트 케이스를 동일하게 하여 반복하면 결함 발견이 안됨)을 방지하기 위해 테스트 케이스 지속적 보완,
  오류-부재의 궤변(결함을 제거해도 요구사항을 만족하지 못하면 품질이 높다고 할 수 없음), 테스트는 작은 부분에서 시작하여 확대, 별도의 테스트 팀에서 수행

### 55) 애플리케이션 테스트의 분류
- 정적 테스트: 프로그램을 실행하지 않고 명세서나 소스 코드 대상 분석하는 테스트, 개발 초기 결함 발견 가능
  ex) 워크스루, 인스펙션, 코드 검사 등
- 동적 테스트: 프로그램을 실행하여 오류 찾는 테스트, 개발 전 단계에서 수행 가능
  ex) 블랙박스 테스트, 화이트박스 테스트
- 테스트 기반에 따른 테스트
  - 명세 기반 테스트: 요구사항 명세를 빠짐없이 테스트 케이스로 만듬 ex) 동등 분할, 경계 값 분석 등
  - 구조 기반 테스트: 소프트웨어 내부 논리 흐름에 따라 테스트 케이스 작성 ex) 구문 기반, 결정 기반, 조건 기반 등
  - 경험 기반 테스트: 테스터 경험 기반, 명세가 불충분하거나 시간 제약이 있을 때 효과적 ex) 에러 추정, 체크 리스트, 탐색적 테스팅 등
- 시각에 따른 테스트: 검증(개발자 시각), 확인(사용자 시각)
- 목적에 따른 테스트: 회복(결함 후 복구), 안전(불법 침입으로부터 보호), 강도(과부하시 정상 실행), 성능(응답시간, 처리량), 구조(논리 경로 및 복잡도), 회귀(코드 변경에 새 결함 없음 확인), 병행(변경된 소프트웨어에 동일한 데이터를 넣었을 때 기존과 비교)

### 56) 테스트 기법에 다른 애플리케이션 테스트
- 화이트박스 테스트: 모듈의 원시 코드를 **오픈**시킨 상태에서 **모든 논리 경로를 테스트**하여 테스트 케이스 설계
  => 모듈 안 작동 직접 , 구조 기반 테스트
  - 기초 경로 검사: 수행 가능 모든 경로 검사, 논리적 복잡성 측정
  - 제어 구조 검사: 조건 검사, 루프 검사, 데이터 흐름 검사(변수 기준)
  - 검증 기준: 문장(모든 구문이 한번 이상 수행), 분기(모든 조건문이 true/false에 대해 한번 이상 수행), 조건 검증(조건문 내부 개별 조건식에 대해 한번 이상 수행), 분기/조건 검증
  - 기능 기반 커버리지(테스트가 수행된 기능 수/전체 기능 수), 라인 커버리지(테스트 수행된 코드 라인 수/전체 라인 수), 코드 커버리지(구조 코드 테스트 정도)
- 블랙박스 테스트: 구조를 고려하지 않고, 기능이 완전히 동작되는 것을 입증하는 테스트 설계
  => 테스트 후반 소프트웨어 인터페이스에서 실행, 명세 기반/경험 기반 테스트
  - 동치 분할 검사: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사, 입력 자료 타당한 것과 아닌 것 균등하게 함
  - 경계값 분석: 입력 자료에만 치중한 동치 분할 검사를 보완해 중간값보다 경계값을 테스트 케이스로 선정하여 검사
  - 원인-효과 그래프 검사: 입출력 관계 체계적으로 분석하여 효용성 높은 테스트 케이스 선정
  - 오류 예측 검사: 과거 경험이나 확인자의 감각으로 테스트
  - 비교 검사: 여러 버전에 동일 테스트 자료에 대해 동일 결과가 출력되는지 테스트

### 57) 개발 단계에 따른 애플리케이션 테스트(테스트 레벨)
- V모델: 요구사항 -> 분석 -> 설계 -> 구현 | 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
- 단위 테스트: 단위 기능 구현된 모듈/컴포넌트에 대해 테스트 진행(구조/명세 기반 테스트) ex) 내부 알고리즘, 반복문, 계산 수식 등
- 통합 테스트: 단위 테스트가 완료된 모듈들을 결합하는 과정에서 상호 작용 오류 검사
- 시스템 테스트: 소프트웨어가 컴퓨터 시스템에서 완벽하게 수행되는지 점검, **기능적** 요구사항(**명세** 기반의 **블랙박스** 테스트 시행), **비기능적** 요구사항(**구조** 기반의 **화이트박스** 테스트 시행)
- 인수 테스트: 요구사항 충족하는지 중점을 두고 테스트, 사용자 인수 테스트(시스템 사용 적절성 여부), 운영상 인수 테스트(시스템 관리자가 테스트, 백업/복원, 복구/관리/점검 등), 계약 인수 테스트(계약상 조건), 규정 인수(정부 지침, 규정에 맞게 개발되었는지 확인), 알파 테스트(사용자가 개발자 앞에서 행하는 테스트, 통제된 환경에서 진행), 베타 테스트(사용자가 여러 사용자들 앞에서 행하는 테스트, 필드 테스팅, 개발자 통제 x)

### 58) 통합 테스트
- 비점진적 통합 방식: 결합된 프로그램 전체 테스트, 빅뱅 통합 테스트 방식(상호 인터페이스 고려x, 한꺼번에), 규모가 작은 소프트웨어에 적합, 오류 발견 및 위치 파악, 수정이 어려움
- 점진적 통합 방식: 모듈 단위로 단계적으로 통합하며 테스트, 오류 수정에 용이
- 점진적 통합 방식 종류
  - 하향식 통합 테스트: 상위 모듈->하위 모듈, 테스트 초기부터 구조를 보여줄 수 있음(빠른 파악), 상위 모듈에서는 테스트 케이스 사용이 어려움, 회귀 테스트 실시, 종속 모듈을 **스텁**(**필요 조건** 갖는 시험용/가짜 모듈, 하위 모듈 대체)으로 대체
    - 깊이 우선 통합법: 종속된 모든 모듈 통합한 순서
    - 넓이 우선 방식: level 순서
  - 상향식 통합 테스트: 하위 모듈->상위 모듈, 종속 모듈 그룹인 클러스터와 더미 모듈인 **드라이버**(**매개변수 전달** 인터페이스 역할, 상위 모듈 대체, 하위 모듈 호출) 필요 
  - 혼합식 통합 테스트: 하위 수준에서는 상향식, 상위 수준에서는 하향식 통합 -> 샌드위치식 통합 테스트
  - 회귀 테스트: 테스팅 반복, 새로운 오류 발생하지 않음 보증, 변경된 부분 테스트 케이스 선정, 파급 효과 높은 부분 선정

### 59) 애플리케이션 테스트 프로세스
- 과정: 계획->분석->테스트 케이스 작성(테스트용 스크립트)->테스트 수행->결과 평가->결함 추적
  독립적인 테스트 환경 구축이 힘들시 가상 머신 기반 서버/클라우드 환경 구축, VLAN으로 논리적인 분할 환경 구축
  테스트 진행시 오류 발견은 빠를수록 좋음(요구사항 분석)

### 60) 테스트 케이스/테스트 시나리오/테스트 오라클
- 테스트 케이스: 테스트 항목에 대한 **명세서**, 시스템 설계 단계에서 작성
  작성 순서: 계획 검토/자료 확보->위험 평가 및 우선순위 결정->요구사항 정의->테스트 구조 설계->테스트 케이스 정의->타당성 확인 및 유지보수
- 테스트 시나리오: 테스트 케이스 적용 **순서**에 따라 테스트 케이스들을 묶은 집합, 구체적인 절차, 사전 조건, 입력 데이터, 예상 결과 등이 설정, 모듈 연계가 정상 동작하는지 테스트, 여러 시나리오 존재 가능
- 테스트 오라클: 테스트 결과 판단을 위해 **참 값을 대입해 예상 결과 계산**
  특징: 제한된 검증, 수학적 기법, 자동화 기능(실행, 결과 비교, 커버리지 측정)
  종류: 참 오라클(모든 테스트 케이스 입력값에 대해 기대 결과 제공->모든 오류 검출 가능), 샘플링 오라클(특정 케이스 입력값에 대해만 기대 결과 제공), 추정(휴리스틱) 오라클(샘플 오라클 개선, 나머지 입력 값들에 대해 추정 처리), 일관성 검사 오라클(애플리케이션 변경 전후로 테스트 케이스 수행 결과 값이 동일한지 확인)

### 61) 테스트 자동화 도구
- 테스트 자동화: 스크립트 형태로 테스트 절차 작성 -> 휴면 에러 줄이고 정확성/일관성 유지 및 품질 향상
- 도구 유형
  - 정적 분석 도구: 프로그램을 실행하지 않고 분석, 코딩 표준/스타일/복잡도/결함 발견, 소스 코드 이해 필요
  - 테스트 케이스 생성 도구: 자료 흐름도/기능 테스트/입력 도메인 분석(내부 참조X)/랜덤 테스트
  - 테스트 실행 도구: 스크립트 언어 사용, 데이터 주도 접근 방식(데이터 저장, 테스트 데이터만 추가하면 미리 작성된 스크립트 기반 테스트 가능), 키워드 주도 접근 방식(테스트 수행 동작 키워드와 데이터를 저장)
  - 성능 테스트 도구: **인위적으로 조건을 적용한 가상의 사용자**를 만들어 테스트 수행
  - 테스트 통제 도구: 테스트 **계획/수행/결함 관리** 수행하는 도구, 형상 관리 도구/결함 추적 도구
  - 테스트 하네스 도구: 컴포넌트 및 모듈을 **테스트하는 환경의 일부**, 테스트 지원을 위해 생성된 코드와 데이터
    구성 요소: 테스트 드라이버(하위 모듈 호출/매개변수 전달/결과 도출), 테스트 스텁(일시적으로 필요한 조건만을 가지고 있는 테스트 모듈), 테스트 슈트(테스트 케이스 집합), 테스트 케이스(명세서), 테스트 스크립트(자동화된 테스트 실행 절차 명세서), 목 오브젝트(사전에 행위를 조건부로 입력해 두면 예정된 행위 객체)
- 수행 단계별 자동화 도구 사용
  계획 단계(요구사항 관리)->테스트 분석/설계(테스트 케이스 생성 도구)->테스트 수행(정적/동적 분석, 성능 테스트, 모니터링)->테스트 관리(커버리지 분석, 형상 관리, 결함 추적)

### 62) 결함 관리
- 지표: 결함 분포(결함 수), 결함 추세(진행 시간에 따른 결함 수 추이), 결함 에이징(결함 지속 시간)
- 분류: 시스템 결함(앱 환경/DB 처리), 기능 결함, GUI 결함, 문서 결함
- 심각도: High(진행 막음), Medium(시스템 흐름에 영향), Low(표기, 미출력, 철자오류 등)
- 결함 관리 도구: Mantis, Trac, Redmine, Bugzilla

### 63) 애플리케이션 성능 분석
- 성능 측정 지표: 처리량, 응답시간, 경과시간, 자원 사용률
- 성능 테스트 도구: JMeter, LoadUI, OpenSTA -> 부하 테스트/스트레스 테스트
- 시스템 모니터링 도구: 시스템 자원 사용량 분석 ex) Scouter, Zabbix
- 성능 저하 원인 분석: db에 많은 데이터 요청, db 락(좌석 생각) 해제 대기, 커넥션 풀 크기 설정 문제, 미들웨어 사용 후 종료하지 않아 연결 누수 발생, 트랜잭션 커밋되지 않고 커넥션 풀에 반환, 커밋 자주 발생, 접속 불량으로 인한 읽기 수행 불가, 대량 파일 업로드/다운로드시 발생하는 처리시간 길어지는 문제, 외부 호출 타임아웃, 전송 지연

### 64) 복잡도
: 시스템 구성 요소 또는 소프트웨어의 복잡한 정도 -> 자원 소요 예측에 사용, 측정 방법으로 LOC(Line Of Code), 순환 복잡도 방식 존재
- 시간 복잡도: 알고리즘 실행시간 수치화, 실행 횟수를 표기하는 점근 표기법 사용
  - 점근 표기법 종류: 빅오 표기법(최악), 세타 표기법(평균), 오메가 표기법(최상)
    빅오 표기법이 성능 예측에 용이하여 주로 사용
    ex) O(1)은 스택의 push/pop, O(log2n)은 이진 트리, 이진 검색, O(n)은 for문, O(nlog2n)은 힙 정렬, 2-way 합병 정렬, O(n2)은 삽입/쉘/선택/버블/퀵 정렬, O(2n)은 피보나치 수열
- 순환 복잡도(맥케이브 순환도): 논리적인 복잡도 측정, 독립적인 경우의 수 정의, 모든 경로가 한 번 이상 수행
  제어 흐름도 G에서 순환 복잡도 V(G) = E(화살표 수) - N(노드 수) + 2 = 영역 수(외부 영역 포함)

### 65) 애플리케이션 성능 개선
- 최적화: 스파게티 코드(로직이 서로 복잡하게 얽혀있는 코드), 외계인 코드(오래되고 유지 보수가 어려운 코드) 수정
  작성 원칙: 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
- 최적화 유형
  - 클래스 분할 배치: 클래스는 단일 역할 하게 해 응집도를 높이고 크기를 줄임
  - 느슨한 결합: 인터페이스 클래스를 이용하여 추상화 -> 의존성 최손화
  - 형식 준수: 줄 바꿈, 개념적 유사성이 높은 종속 함수 사용, 호출하는 함수 선배치/호출되는 함수 후배치, 지역 변수 처음에 선언
  - 명명 규칙 준수, 적절한 주석
- 소스 코드 품질 분석 도구: 정적 분석 도구(실행하지 않고 초기 결함 찾고 검증, pmd/cppcheck/SonarQube/checkstyle/ccm 등), 동적 분석 도구(실행을 통해 메모리 누수, 스레드 결함 등 분석, Avalanche, Valgrind 등)

### 66) 모듈 간 공통 기능 및 데이터 인터페이스 확인
- 데이터 인터페이스: **모듈 간 교환되는 데이터**가 저장될 파라미터
- 인터페이스 설계서: 시스템 사이 교환 데이터 및 관련 업무 내용 정의
  - 일반적: 시스템 인터페이스 설계서, 상세 기능별 인터페이스 명세서
  - 정적/동적 모형을 통한 인터페이스 설계서: 다이어그램 이용, 인터페이스가 시스템 어디에 속하고 트랜잭션 종류 확인 가능
- 설계서별 모듈 기능 확인: 인터페이스 목록/설계서에서 송신 및 전달 부분은 외부 모듈, 수신 부분은 내부 모듈, 상세 기능 **인터페이스 명세서**에서 오퍼레이션과 **사전 조건**은 외부 모듈, **사후 조건**은 내부 모듈, 정적/동적 모형을 통한 인터페이스 설계에서 인터페이스 영역 기준으로 상위 모듈이 외부 모듈, 하위 모듈이 내부 모듈 => 외부->내부

### 67) 모듈 연계를 위한 인터페이스 기능 식별
- 모듈 연계: 내부와 외부 모듈간 또는 내부 모듈 간 데이터 교환을 위해 관계 설정
  - EAI 방법: 기업 내 앱 또는 **플랫폼간** 정보 전달, 연계, 통합 등 **상호작용**이 가능하게 해주는 솔루션, 확정성을 높임
    - 유형: Point-to-Point(1:1, 기본적, 변경 및 재사용이 힘듬), Hub & Spoke(중앙 집중형 허브, 확장 및 유지보수에 유리), Message Bus(ESB 방식, 애플리케이션 간에 미들웨어를 두어 처리, 확장성 뛰어나고 대용량 처리 가능), Hybrid(그룹 내에서 Hub&Spoke, 그룹 간은 Message Bus 혼합, 병목 현상 최소화)
  - ESB 방법: **서비스 중심**의 통합 지향, 범용적 사용을 위해 결합도를 약하게 유지, 관리 및 유지 쉬움
- 모듈 간 인터페이스 기능 식별: 외부 모듈 및 인터페이스 모듈 간 동작 기능에 기반하여 인터페이스 기능 식별, 내외부 모듈을 통해 연계된 기능을 시나리오 형태로 구체화, 필요한 안터페이스 기능 종합 식별

### 68) 모듈 간 인터페이스 데이터 표준 확인
- 순서
  - **데이터 인터페이스** 확인: 입출력 의미 및 데이터 특성 확인, 데이터 표준 확인
  - **인터페이스 기능** 확인: 기능 구현을 위해 필요한 데이터 항목 확인
  - **인터페이스 데이터 표준** 확인: 최종적으로 데이터 표준 확인, 출처 구분하여 기록

### 69) 인터페이스 기능 구현 정의
- 순서
  - 컴포넌트 명세서 확인: 컴포넌트 개요 및 내부 클래스 동작, 인터페이스를 통해 외부와 통신하는 명세 정의
  - 인터페이스 명세서 확인: 인터페이스 클래스 세부 조건 및 기능 정의
  - 모듈 세부 설계서 확인
  - 인터페이스 기능 구현 정의 및 정형화: 일관성, 세부 정의, 표준화, 가독성을 높이기 위해 프로세스 형태나 유스케이스 다이어그램 형태로 정형화

### 70) 인터페이스 구현
- 데이터 통신을 이용한 인터페이스 구현
: 애플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 전송하고, 수신 측에서 파싱하여 해석, json, xml 형식 사용
- 인터페이스 엔티티를 이용한 인터페이스 구현
: 인터페이스 엔티티를 두고 상호 연계, 일반적으로 인터페이스 테이블이 엔티티 역할, 개수/구조 가변적
* AJAX: JavaScript를 이용한 비동기 통신 기술, 클라이언트와 서버 간에 xml 데이터를 주고받음

### 71) 인터페이스 예외 처리
- 데이터 통신을 이용한 인터페이스 예외 처리
  : json, xml 등 인터페이스 객체를 이용한 인터페이스 동작이 실패할 경우 대비
  ex) 송신 실패: 네트워크 불안정(post 이후 오류 메시지, 404 오류), 송신 데이터 크기/정합성 체크 오류(데이터 정제, 체크 기능 추가), 프로세스 논리적 결함
  ex) 수신 실패: 네트워크/서버 불안정(대기 큐에 요청 적재 후 순차 처리), 수신 데이터 파싱 오류, 처리 과정에서 프로세스 논리적 결함
- 인터페이스 엔티티를 이용한 인터페이스 예외 처리
  : 엔티티(**테이블**)에 실패 상황과 원인 기록하고 알려주는 방식

### 72) 인터페이스 보안
- 적용
  - 네트워크 영역: 송수신간 sniffing 등을 이용한 탈취 및 변조 위협 방지를 위해 트래픽 암호화
    - IPSec: **IP 패킷 단위** 데이터 변조 방지 및 은닉
    - SSL: **TCP/IP 계층과 애플리케이션 계층 사이** 인증 및 암호화
    - S-HTTP: **클라이언트와 서버 간** 전송되는 모든 메시지 암호화 
  - 애플리케이션 영역: 애플리케이션 코드 상 보안 취약점 보완
  - 데이터베이스 영역: 프로시저, 트리거 등 동작 객체의 보안 취약점에 보안 기능 적용, 민감한 데이터의 자체 보안 방안
- 데이터 무결성 검사 도구: 인터페이스 보안 취약점 분석, 크래커가 침입하여 백도어를 만들거나 설정 파일을 변경했을 때 감지, 해시 함수 이용하여 상태가 달라지면 변경 사실 알림, ex) Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck

### 73) 연계 테스트
: 연계 시스템 구성 요소(송수신 모듈, 연계 서버, 모니터링 현황)가 정상 동작하는지 확인
- 연계 테스트 케이스 작성: 송수신용 연계 응용 프로그램 단위 테스트 케이스(유효값 확인, 연관 관계 확인)와 연계 테스트 케이스(기능상 결함 확인하는 단위 테스트 케이스 형태, 흐름 확인용)
- 연계 테스트 환경 구축: 송수신 기관과의 협의를 통해 환경(서버, 어댑터, ip/port, db 작업) 구축
- 연계 테스트 수행: 단위 테스트 후 연계 테스트 수행
- 수행 결과 검증: db 테이블 건수 확인, 데이터 확인, 파일 생성 여부 및 크기 확인, 모니터링 현황 확인, 로그 확인

### 74) 인터페이스 구현 검증
- 구현 **검증** 도구
: 통합 테스트 수행을 위한 도구
  - xUnit: 테스트 코드 템플릿화, 테스트마다 자동화된 해법 제공하는 단위 테스트 프레임워크, 이름이 언어와 연결
  - STAF: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임 워크, 크로스 플랫폼/분산 소프트웨어 환경 조성(데몬이 테스트 응답 대신하고 완료시 통합하여 자동화)
  - FitNesse: 웹 기반 테스트 프레임워크
  - NTAF: FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성 통합한 NHN의 테스트 프레임워크
  - Seleniumm: 웹 애플리케이션 테스트 프레임워크
  - watir: ruby를 사용하는 앱 테스트 프레임워크
- 구현 **감시** 도구
: 동작 상태를 APM을 사용해 감시, 스카우터, 제니퍼와 같은 성능 관리 도구를 사용해 종합 정보 분석
*APM: 성능 관리 모니터링, 리소스 방식의 Nagios, Zabbix와 엔드투엔드 방식의 VisualVM, 스카우터, 제니퍼 등이 있음

### 75) 인터페이스 오류 확인 및 처리 보고서 작성
- 즉시 처리: 알람/이메일/SNS
- 주기적 처리: 시스템 로그 파일, 테이블 기록(테이블의 경우 오류사항 구체적이지 않아 분석 필요)
- 오류 처리 보고서: 신속하게 작성, 정형화된 형식 존재 X, 시간 경과에 따라 기록