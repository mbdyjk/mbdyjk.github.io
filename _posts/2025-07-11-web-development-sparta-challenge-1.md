---
title: "웹개발 수업 복습 - 스파르타 챌린지반 학습자료(1)"
date: 2025-07-11
categories: [React]
tags: [React]
---

스파르타 리액트 부트캠프 과정을 5월에 마치고, 휴식의 시간을 가지며 취업 스터디를 통해 개발을 조금씩 이어나가다, 소개받은 기업에서 이력서를 좋게 봐주셔서 미팅을 갖게 될 예정이다. 개발에 몰두하던 때의 감을 되찾고자 스파르타 부트캠프에서 배웠던 학습자료를 다시 읽고 정리하려고 한다.
23회차까지 진행된 수업자료와 공식문서들을 꼼꼼히 읽어보며 핵심 부분만 정리하는 포스트가 될 것이다.

## 1. 웹의 역사
### 초기 웹
- HTML뿐: CSS, JS 기술이 없어 텍스트와 링크로만 구성된 단순한 형태
- HTTP 프로토콜: 웹에서 브라우저와 서버 간에 데이터를 주고 받기 위한 규칙인 HTTP를 통해 서버로부터 해당 URL 주소에 있는 HTML 파일을 받아 렌더링
### 웹 2.0
- CSS, JavaScript와 같은 기술들이 발전하며 디자인과 상호작용성이 향상
- V8과 Node.js의 등장: V8의 등장으로 기존 한 줄씩 읽어서 실행하는 인터프리터 방식에서 코드 실행 전 기계어로 번역해서 실행하는 JIT 컴파일 방식으로 **인라인 캐싱**으로 인한 성능 향상을 이루어짐, Node.js를 통해 서버 사이드 기능이 추가되어 브라우저 밖에서도 자바스크립트가 사용 가능해짐
### 모던 웹
- 스마트폰의 보급으로 반응형 웹 디자인 중요성 증가
- SPA 등장으로 사용자 경험 향상 및 다양한 프레임워크와 라이브러리 등장

## 2. React?
### 리액트 이전 웹 개발(jQuery 등)
- 복잡한 UI 관리: 간단한 인터렉션에도 페이지 전체 새로고침, DOM 자체가 무거워서 직접 조작시 성능 문제 야기

  * DOM: HTML 구조를 트리 형태 객체로 표현한 것, 브라우저는 HTML을 파싱해서 DOM 트리를 만들고, 자바스크립트로 DOM을 조작하여 웹페이지 내용/구조를 동적으로 변경할 수 있다. 반복적인 DOM 조작이나 복잡한 변경은 리플로우, 리페인트 과다 발생/메모리 사용량 증가/개별 처리로 인한 비효율성 문제를 야기

- 데이터와 UI 상의 상태 동기화 결정 필요
- 재사용성이 낮음: UI/비즈니스 로직이 밀접하게 결합
- 반응성, 상호작용성 낮음
### React 특징
- **가상 DOM**: 실제 DOM을 메모리에 복제한 형태로, 메모리에서 변경 사항을 먼저 처리하고 가상 DOM끼리 비교하여 변경점을 찾아 차이점만 실제 DOM에 한번에 반영해 최소한의 업데이트로 성능 최적화, 페이지 새로고침 없이 모바일 앱처럼 부드럽고 즉각적인 사용자 경험 제공
- **컴포넌트** 기반
- **선언적** 접근: "무엇을" 작업해야하는지에 초점을 맞춰 코드 가독성 및 간결성, 유지보수 용이성 측면에서 이점을 가짐
- 
## 3. React로 사고하기
참고문서: https://ko.react.dev/learn/thinking-in-react
### Step1. UI를 컴포넌트 계층으로 쪼개기
: 모의 시안에 있는 컴포넌트 주변에 박스를 그리고 이름을 붙이며 시작, 디자이너와 컴포넌트 설계에 대해 미리 이야기 나누기, 계층 구조로 정리

- 컴포넌트 설계시 고려사항: 단일 책임원칙, 클래스 선택자, 디자인 계층 고려 필요

- 클래스 선택자 고민 요소
  1) 클래스 네이밍 규칙
   - BEM(Block Element Modifier): 네이밍 규칙 중 하나, **Block**(독립적인 UI 컴포넌트/모듈, block), **Element**(블록 내 포함된 하위 요소, __element), **Modifier**(블록이나 요소의 상태, 스타일, 테마, --modifier)으로 구성 
   ex) .nav-menu__item--active
   - 표기법: PascalCase, camelCase, kebab-case, snake_case
   - 목적을 반영한 의미적 이름
  2) 컴포넌트 세분화
    : 각 컴포넌트에 고유한 클래스 선택자를 만들어 스타일 모듈화
  3) 가상 DOM과의 연계
    : 조건부 스타일링시 변경되는 요소만 클래스 선택자로 다르게 하여 필요한 업데이트만 수행
  4) 스타일링 방식 선택
    - CSS 클래스 선택자
    - CSS-in-JS: Styled Component처럼 자바스크립트로 스타일 정의
    - Tailwind CSS: 유틸리티 클래스를 사용하여 빠르게 스타일링

### Step2. React로 정적인 버전 구현하기
: 이 단계에서는 상호작용 기능은 구현하지 않고, 데이터 모델로부터 UI를 렌더링하는 버전을 만드는 단계, 즉 state 같은 상호작용적 요소가 아닌, props 위주 코딩 진행

이 때, 하향식(상층부->하층부), 상향식(하층부->상층부)를 선택할 수 있고, 간단한 예시는 하향식이 쉽지만 프로젝트가 커지면 상향식으로 만들고 테스트를 작성하며 개발하는 것이 더 쉬움

### Step3. 최소한의 데이터만 이용하여 완벽하게 UI state 표현하기
state 설계시 **중복 배제 원칙**을 준수하여 최소한의 state를 파악하고 나머지는 필요에 따라 실시간으로 계산
ex) 상품 아이템의 개수를 노출시키려고 할 때, 아이템 배열의 길이 사용
=> 불변하거나, props로 전달되거나, 다른 state/props로 계산 가능한 경우 state로 사용하지 않는다.

### Step4. state가 어디에 위치해야 할지 정하기
해당 값을 필요로 하는 공통 부모 컴포넌트에 위치

### Step5. 역 데이터 흐름 추가하기
사용자 입력에 따라 state를 변경하려면 역 방향 데이터 흐름을 만들어야 함, state의 set 함수를 컴포넌트 이벤트로 등록하여 역흐름 제어 구현