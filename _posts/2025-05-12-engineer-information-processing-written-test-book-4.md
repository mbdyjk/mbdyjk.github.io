---
title: "정보처리기사 필기 책 4과목 개념문제 풀기 및 개념 정리"
date: 2025-05-12
categories: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
tags: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
---

# 정보처리기사 실기 책 4편

## 4. 프로그래밍 언어 활용

### 127) 개발 환경 구축
- 하드웨어 환경: 서버/클라이언트
  - 웹서버: 저용량 정적 파일 제공 ex) HTTP Server, Web Server
    - HTTP/HTTPS 지원, 통신 기록, 정적 파일 관리, 대역폭 제한, 가상 호스팅(하나의 서버로 여러 개의 도메인 이름 연결), 인증
  - WAS: 동적 서비스 제공, 가공 및 DBMS와의 인터페이스 역할 수행 ex) Tomcat, WebSphere
  - DBMS: 데이터베이스 관리 ex) MySQL, Oracle, MSSQL
  - 파일 서버
- 소프트웨어 환경: 시스템 소프트웨어(서버/클라이어트 운영), 개발 소프트웨어
  - 시스템 소프트웨어: OS, DBMS 등
  - 개발 소프트웨어: 요구사항 관리도구(지라, 트렐로 등), 설계/모델링 도구(UML 지원, DB Designer 등), 구현 도구(Eclipse, IntelliJ, Visual Studio, Nodejs 등), 빌드 도구(Ant, Gradle, Maven, Jenkins 등), 테스트도구(CppUnit, JUnit, HttpUnit, NUnit 등), 형상 관리 도구(Git, Subversion, CVS, Mercurial 등)

### 128) 서버 개발
: 서버 프로그램을 작성하여 WAS에 탑재
- 프레임워크 종류(주로 mvc 패턴 기반 개발): Spring(Java 기반), Nodejs(JavaScript 기반, 비동기/이벤트 처리 성능 우수), Django(Python 기반, 컴포넌트 재사용과 플러그인화 강조), Codeigniter(PHP 기반, 인터페이스 간편, 자원 적게 사용), Rails(Ruby 기반, 단순신속)

### 129) 보안 및 API
- 보안의 3요소: 기밀성(인가된 사용자만 접근 허용), 무결성(인가된 사용자만 수정 가능), 가용성(인가된 사용자는 언제라도 사용 가능)
- API: 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의한 인터페이스

### 130) 배치 프로그램
: 사용자와의 **상호 작용 없이** 여러 작업들을 정해진 **일련의 순서**에 따라 일괄 처리하는 프로그램
- 종류: 정기 배치, 이벤트성 배치, On-Demand 배치
- 배치 스케줄러: 스프링 배치, Quartz

### 131) 패키지 소프트웨어
: 기업에서 일반적으로 사용하는 기능들을 통합하여 제공하는 소프트웨어
전용 개발 소프트웨어와 비교하여 호환성 및 유지보수 측면에서 단점 존재

### 132) 데이터 타입
- C/C++에서 char 1바이트, long 4바이트(windows 기준)
- java에서 char 2바이트, long 8바이트
- python에서 str, int가 무제한, float 8바이트, tuple은 요소 연속적 저장 가능, 추가/삭제/변경 불가

### 133) 변수
- 작성 규칙: 첫글자 숫자 불가, 공백이나 특수문자 사용불가, 예약어 사용불가, 헝가리안 표기법으로 변수명에 데이터 타입 표시 가능
- 기억 클래스: 변수 값을 저장하기 위한 기억영역 결정 작업 담당
  - auto: 메모리(스택)에 저장, 블록 내 선언, 범위 벗어나면 자동 소멸, 초기화하지 않으면 쓰레기값 저장
  - register: cpu 내부 레지스터에 저장, 자주 사용되는 변수를 레지스터에 저장해 처리속도 높임, 블록 스코프, 할당 개수 한정, 메모리 주소를 가질 수 없음
  - static: 메모리(데이터)에 저장, 블록 내외부 선언 가능, 블록 종료 후에도 값 소멸하지 않음, 초기화 한번만 가능
  - extern: 메모리(데이터)에 저장, 스코프 외부 선언/참조, 초기화하지 않으면 0으로 자동 초기화

### 134) 연산자
- 산술 연산자
- 관계 연산자
- 비트 연산자 ex) &(and), ^(xor), |(or), ~(not), <<(왼쪽 시프트), >>(오른쪽 시프트)
- 논리 연산자
- 대입 연산자
- 조건 연산자 ex) 삼항 연산자
- 기타 연산자 ex) sizeof, 콤마, (자료형)->캐스트 연산자
- 연산자 우선순위: 단항 연산자>이항 연산자>삼항 연산자>대입 연산자>순서 연산자
  - 단항 연산자: !, ~, ++, --, sizeof
  - 이항 연산자: 산술>시프트>관계>비트>논리 즉, 일반 계산>시프트>비교>비트/논리

### 135) 데이터 입출력
- c언어: scanf(서식문자열, &변수주소), printf(서식문자열, 변수)
  - 서식문자열 예시: %d(정수형 10진수), $c(문자), %s(문자열), %f(실수), %x(16진수), %u(부호없는 정수형)
  * 배열은 배열명이 시작 주소를 나타내므로 &를 붙이지 않아도 됨
- java: Scanner scan01 = new Scanner(System.in); inNum = scan01.nextInt(); 또는 next(), nextLine(), nextFloat(), out 클래스의 메서드 System.out.printf(서식문자열, 변수), System.out.print(), System.out.println;다음줄로 이동
  * 숫자+숫자는 연산결과를 숫자로, 문자+숫자는 둘을 붙여서 문자로 출력
- 기타 표준 입출력 함수
  - getchar(): 한 문자를 입력받아 변수에 저장
  - gets(): enter 키를 누르기 전까지 문자열을 입력받아 변수에 저장
  - putchar(): 주어진 한 문자를 화면에 출력
  - puts(): 문자열 출력, 다음줄 앞으로 이동
- 아스키 코드: 문자 저장시 아스키코드로 저장됨, '0': 48, 'A': 65, 'a': 97

### 136) 제어문
- if문
  * 괄호에 대입연산자를 사용했을 경우 항상 true
- switch-case문
- goto문

### 137) 반복문
- for문
- while문
- do~while문: do 내용을 무조건 한번 실행하고 조건 판별
- break: 블록을 바로 빠져나옴
- continue: 반복문에서 다음 반복으로 넘어가는 역할

### 138) 배열과 문자열
- 배열: 1차원배열/2차원배열(행개수/열개수)
  초기화: 크기 지정시 값 입력 또는 기본값, 크기 생략할 경우 반드시 초기값 설정, 그만큼 크기 배정
  * c string 메서드: strcat(str1, str2) = str1str2
  * java string 메서드: length(), charAt(index), ...
  * 배열 이름 출력시 배열의 시작 주소 출력하게 됨

### 139) 포인터
메모리 그림을 그려서 풀기
- 포인터로 배열 접근하기: *(배열명+index)

### 140) Python 기초
- 특징: 자료형 선언이 없음, 세미콜론 사용안함, 변수 여러개에 연속하여 값 저장 가능, 코드 블록 명령문은 콜론과 명령문으로 대체
- 입력함수: 변수 = input(출력할 문자)
  split을 통해 분리문자로 분리하여 각 변수에 값 할당
  * 입력값의 형변환
  - 변환할 데이터 1개일 때: 변수 = 타입(input())
  - 변환할 데이터 2개 이상일 때: 변수1, 변수2, ... = map(타입, input().split())
- 출력함수: print(출력값1, 출력값2, ..., sep=분리문자, end=종료문자), 여러 개 출력시 공백으로 분리
  또는 print('서식 문자열' % (출력값1, 출력값2, ...))
  ex) print('%-8.2f' % 200.20) -> 왼쪽부터 출력, 8자리로 출력, 소수점 둘쨰자리까지 표시
- 리스트: 리스트명 = list([값1, 값2, ...])
- 딕셔너리: 딕셔너리명 = dict({키1:값1, 키2:값2, ...})
- range(최종값), range(초기값, 최종값), range(초기값, 최종값, 증가값)
- slice: 객체명[초기위치:최종위치:증가값], 생략 가능, 초기위치 인덱스에서 최종위치 이전 인덱스까지

### 141) Python 활용
- if문: if, elif, else
- for문: for 변수 in range(최종값):
  또는 for 변수 in 리스트
- while문: while 조건
- 클래스: 변수 및 함수(def) 선언

### 142) 절차적 프로그래밍 언어
: 일련의 처리 절차를 문법에 따라 순차적으로 실행
-> 실행 속도 빠름, 모듈 구성 용이, 분석 및 유지보수/수정 어려움
- 종류: C(시스템 프로그래밍, 고급/저급 언어 특징, 컴파일러 방식), ALGOL(수치 계산), COBOL(사무 처리용), FORTRAN(과학기술 계산 언어)

### 143) 객체지향 프로그래밍 언어
: 객체를 조합하여 프로그램 작성 기법
-> 상속을 통한 확장 용이, 재활용성 높음, 대형 프로그램 작성 용이, 유지보수 용이, 정형화된 분석/설계방법 없음, 처리시간 다소 소요
- 종류: Java(분산 네트워크, 멀티스레드 기능, 운영체제/하드웨어 독립적, 이식성 재사용성 높음), C++, Smalltalk(GUI 제공)
- 특징: 캡슐화(속성과 함수를 하나로 묶어 외부로부터 은폐, 재사용성 높임), 정보 은닉(오류 파급효과 적음), 추상화(공통 성질 추출하여 중요한 부분에 중점을 두어 개략화), 상속성(하위 클래스가 물려받음), 다형성(하나의 메시지에 대해 다르게 표현될 수 있음, 오버로딩/오버라이딩)

### 144) 스크립트 언어
: HTML 문서 안에 프로그래밍 언어 삽입, 컴파일 되지 않고 번역기가 소스 분석하여 동작
- 서버용 스크립트 언어: 서버에서 해석되어 실행된 후 결과만 클라이언트로 보냄, ASP(Windows 계열에서만 수행 가능, 서버 측에서 동적으로 수행되는 페이지 만듬), JSP(Java 기반), PHP(C, Java와 문법 유사), 파이썬(귀도 반 로섬, 객체지향 지원), 쉘 스크립트(유닉스/리눅스 계열 쉘에서 사용되는 명령어 조합으로 구성된 슼릡트 언어, .sh 확장자 사용)
- 클라이언트용 스크립트 언어: 웹 브라우저에서 해석되어 실행, 자바스크립트(클래스 기반 객체 상속 지원->객체지향 프로그래밍 언어 성격, 프로토타입 개념 가짐), VB 스크립트(마이크로소프트, Active X 사용)
- 특징: 컴파일 없이 바로 실행되므로 결과 바로 확인 가능, 코딩이 쉽고 개발 시간 짧음, 실행 속도가 느리고 런타임 오류 발생

### 145) 선언형 언어
: 프로그램이 수행해야 하는 문제 기술, 알고리즘 명시하지 않음 <-> 명령형 언어(폰노이만, 명령 순서대로 나열)
- 함수형 언어: 수학적 함수 조합하여 문제 해결, 적용형 언어, 재귀호출/병렬 처리 유리 ex) LISP
- 논리형 언어: 논리 문장을 이용해 계산 수행, 선언적 언어, 반복문/선택문 사용하지 않음, 비절차적 언어 ex) PROLOG
- 특징: 가독성/재사용성 좋음, 오류가 적음, 동작을 변경하지 않고 값 대체 가능
- 종류: HTML(웹 표준 문서인 하이퍼텍스트 문서를 위해 사용), LISP(인공지능 분야에서 사용, 연결리스트 구조, 재귀 호출 많이 사용), PROLOG(논리학 기초 고급 언어, 인공지능분야에서 논리 추론에 사용), XML(HTML 단점을 보완하여 웹에서 다양한 문서들 상호교환, 새 태그 정의 가능), Haskell(함수형 언어, 부작용이 없고 에러 발생 가능성 적음)

### 146) 라이브러리
: 프로그램의 효율적 개발을 위해 자주 사용하는 함수나 데이터를 미리 만들어 놓은 집합체
- 특징: 모듈과 패키지 포함, 표준 라이브러리(프로그래밍 언어에 기본 포함)와 외부 라이브러리 존재
- C언어: stdio.h(데이터 입출력), math.h(수학 함수), string.h(문자열 처리), stdlib.h(자료형 변환, 난수, 메모리 할당 등 기능 제공), time.h(시간 처리)
- Java: java.lang(기본 포함, 인터페이스, 자료형, 예외 처리 등), java.util(날짜 처리, 난수, 복잡한 문자열 처리 등 기능 제공), java.io(파일 입출력), java.net(네트워크), java.awt(ui 관련)

### 147) 예외 처리
- Java: java.lang에서 제공, try~catch 문 이용, 문법 오류 제외

### 148) 프로토타입
: 함수 원형 의미로 컴파일러에게 함수에 대한 정보를 미리 알림
- 특징: 함수가 미리 정의되는 경우 정의하지 않아도 됨, 본문 없음, 반환 형식 일치, c언어에서 main 함수 바깥쪽에 선언, main 함수 전에 사용될 함수에 대한 프로토타입 정의 필수

### 149) 운영체제의 개념
: 컴퓨터 시스템 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 프로그램 모임
- 계층: 사용자 - 응용 프로그램 - 유틸리티 - 운영체제 - 하드웨어
- 목적: 처리 능력 향상, 반환 시간, 사용 가능도(사용할 필요가 있을 때 즉시 사용 가능한 정도;가용성), 신뢰도
- 구성
  - 제어 프로그램
    - 감시 프로그램: 자원 할당 및 작동 상태 감시
    - 작업 관리 프로그램: 작업이 정상적으로 처리되도록 순서 및 방법 관리
    - 데이터 관리 프로그램: 데이터와 파일의 처리 및 전송 관리
  - 처리 프로그램
    - 언어 번역 프로그램: 고급언어로 작성한 프로그램을 기계어 기반 프로그램으로 바꿈 ex) 컴파일러, 어셈블러, 인터프리터
    - 서비스 프로그램: 사용자가 효율적으로 사용할 수 있도록 하는 프로그램 ex) 분류/병합, 유틸리티 프로그램
- 기능: 자원 관리, 자원 스케줄링 기능, 편리한 인터페이스 제공, 하드웨어/네트워크 관리제어, 데이터 관리 및 공유, 시스템 오류 검사 및 복구, 자원 보호, 입출력 보조, 가상 계산기

### 150) Windows
- 특징: GUI, 선점형 멀티태스킹(동시에 여러개의 프로그램의 실행하며, 운영체제가 CPU 이용시간 제어->문제 발생시 강제 종료 및 자원 반환), PnP(하드웨어 설치시 필요한 시스템 환경을 os가 자동으로 구성), OLE(응용 프로그램에서 작성된 개체를 현재 작성중인 문서에 자유롭게 Linking 가능->멀티태스킹 가능), 255자의 파일명, 싱글 유저 시스템

### 151) UNIX/LINUX/MacOS
- UNIX: 벨 연구소, MIT, General Electric이 공동 개발
  - 특징: 시분할 시스템, 소스가 공개된 개방형, C언어로 작성되어 이식성/호환성 높음, 다중 사용자/다중 작업 지원, 통신망 관리용 운영체제, 트리구조 파일 시스템
  - 계층: 사용자 - 유틸리티 - 쉘 - 커널 - 하드웨어
  - 커널: 핵심 부분, 컴퓨터 부팅시 주기억장치에 적재된 후 상주, 하드웨어 보호, 프로그램과 하드웨어 사이 인터페이스 역할, 여러 기능 수행(프로세스 **관리**, 기억장치 관리, 파일 관리, 입출력 관리, 통신, 데이터 전송 및 변환)
  - 쉘: 명령 수행하는 **명령어 해석기**, 주기억장치에 상주하지 않고 파일 형태로 존재하며 보조 기억장치에서 교체 처리 가능, 파이프라인 기능 지원, 방향성 변경 가능, 사용자 인터페이스
  - 유틸리티: 응용 프로그램 처리,에디터/컴파일러/인터브리터/디버거 등
  - 프로세스 간 통신: 시그널(메시지 통한 통신), 파이프(한 프로세스의 출력이 다른 프로세스 입력으로 사용되는 단방향 통신), 소켓(프로세스 간 쌍방향 통신)
- LINUX: 토발즈가 UNIX 기반으로 개발힌 운영체제, 공개 소프트웨어, UNIX와 완벽 호환
- MacOS: UNIX 기반 애플 사에서 개발한 운영체제
- 파일 디스크립터(서술자): 사용자가 직접 참조할 수 없음, 파일마다 독립적 존재, 보조기억장치 내에 저장되어 있다가 오픈되면 주기억장치로 옮겨짐, 시스템이 필요로 하는 정보 가짐

### 152) 기억장치 관리의 개요
- 계층 구조: (상위) 레지스터 <-> 캐시 기억장치 <-> 주기억장치 <-> 보조기억장치 (하위)
  - 특징: 상위 기억장치일수록 접근 속도와 시간이 빠르지만 용량이 적고 고가, 주기억장치는 각각 주소를 갖고, 주소를 통해 엑세스 가능, 보조기억장치를 제외하고는 CPU가 직접 액세스 가능
- 관리 전략: 반입 전략(**언제** 주기억장치로 적재할지, 요구 반입-참조 요구시, 예상 반입-실행 중인 프로그램의 참조 예상), 배치 전략(주기억장치 **어디에** 배치할지, 최초 적합-첫번째 분할 영역, 최적 적합-빈 영역 중 단편화를 가장 작게 남기는 분할 영역, 최악 적합-단편화를 가장 많이 남기는 분할 영역), 교체 전략(이미 사용중인 영역 중 어느 영역에서 교체할지 - 페이지 교체 알고리즘)

### 153) 주기억장치 할당 기법
- 연속 할당(로딩) 기법
  - 단일 분할 할당 기법: 주기억장치를 OS영역과 사용자영역으로 나눠 순간마다 한명의 사용자만 사용자 영역 사용, 구분하는 경계 레지스터 존재, 프로그램 크기 작을 경우 사용자 영역 낭비
    - 오버레이: 주기억장치보다 큰 사용자 프로그램 실행을 위한 기법, 분할하여 할당, 주기억장치 **공간 부족시 불필요한 조각에 중첩**하여 적재, 프로그래머가 구조를 알아야 함
    - 스와핑: 프로그램 전체를 주기억장치에 할당해 **필요에 따라 다른 프로그램과 교체** -> 페이징 기법으로 발전
  - 다중 분할 할당 기법
    - 고정 분할 할당(정적 할당): 프로그램 할당 전 OS가 주기억장치의 사용자 영역을 **고정된 크기로 분할**하고 큐에서 준비중인 프로그램을 각 영역에 할당, **일정한 크기**로 분할 영역이 정해져 낭비 발생 가능
    - 가변 분할 할당(동적 할당): 필요한 크기만큼 영역 분할, 효율적 사용, 영역과 영역 사이에 내부 단편화 발생 가능
- 분산 할당 기법: 프로그램을 조각으로 나누어 주기억장치에 분산하여 할당
  - 페이징 기법
  - 세그멘테이션 기법

### 154) 가상기억장치 구현 기법/페이지 교체 알고리즘
- 가상기억장치: 보조기억장치의 일부를 주기억장치처럼 사용하여 주기억장치를 큰 용량을 가진것처럼 사용 가능
- 특징: 프로그램을 블록 단위로 나눠 가상기억장치에 보관하고 요구되는 블록을 주기억장치에 불연속할당, 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 **주소변환** 작업 필요, 단편화 해결
- 페이징 기법: 프로그램을 일정한 크기로 나눠 페이지로 만들고, 주기억장치도 동일한 크기로 나눠(페이지 프레임) 적재, 내부 단편화 발생 가능(나눴을 때 딱 떨어지지 않을 수 있음), 주소 변환을 위해 페이지 맵 테이블 필요 -> 비용 증가 및 처리속도 감소
- 세그멘테이션 기법: 프로그램을 논리적 크기인 세그먼트로 나눠 기억공간 절약, 주소변환에 사용되는 세그먼트 맵 테이블 필요, 다른 세그먼트 침범을 막기 위해 기억장치 보호키 필요, 외부 단편화 발생 가능
  * 주소 변환 방법: 가상 주소 형식이 세그먼트 번호+변위값으로 이루어짐, 변위값은 실제 내용이 위치하고 있는 곳 까지의 거리 나타냄, 즉 실기억주소는 세그먼트 기준번지+변위값
  변위값이 세그먼트 크기(한계번지)보다 작으면 세그먼트 기준번지+변위값에 위치, 클 경우 트랩 발생
- 페이지 교체 알고리즘: 페이지 부재가 발생했을 경우 어떤 페이지 프레임을 선택해 교체할 것인지 결정
  - OPT(Optimal)
  - FIFO(First In First Out)
  - LRU
  - LFU
  - NUR
  - SCR
  
### 155) 가상기억장치 기타 관리 사항

### 156) 프로세스의 개요

### 157) 스케줄링

### 158) 주요 스케줄링 알고리즘

### 159) 환경 변수

### 160) 운영체제 기본 명령어

### 161) 인터넷

### 162) OSI 참조 모델

### 163) 네트워크 관련 장비

### 164) 프로토콜 개념

### 165) TCP/IP