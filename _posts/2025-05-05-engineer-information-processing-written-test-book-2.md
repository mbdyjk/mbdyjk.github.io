---
title: "정보처리기사 필기 책 2과목 개념문제 풀기 및 개념 정리"
date: 2025-05-07
categories: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
tags: [정보처리기사, 필기, 시나공 2023, 2025년 시험]
---

# 정보처리기사 실기 책 2편

## 2. 소프트웨어 개발

### 36) 자료 구조
- 선형 구조
  - 배열
  - 선형 리스트
    - 연속 리스트: 기억 장소를 연속적으로 배정->이용 효율은 밀도가 1로서 좋음, 삽입/삭제시 자료 이동이 필요
    - 연결 리스트: 자료들을 임의의 공간에 기억시키고, 노드의 포인터를 이용해 서로 연결, 삽입/삭제에 용이, 포인터 부분이 필요해 공간 이용 효율이 좋지 않음, 연결을 위한 포인터 찾는 시간이 필요해 접근속도 느림, 중간 노드 연결이 끊어지면 다음 노드를 찾기 힘듬
  - 스택: 함수 호출 순서 제어, 인터럽트 처리, 수식 계산 및 표기법, 컴파일러 이용한 번역, 서브루틴 호출 및 복귀주소 저장, 재귀 호출, 전위/후위 표현 연산, 깊이 우선 탐색
    꽉 채워져있을 때 삽입시 오버플로, 비어있을 때 삭제시 언더플로
    M: 스택 크기, Top: 스택 포인터(최근 자료), Bottom
  - 큐: 운영체제 작업 스케줄링
    F: 가장 먼저 삽입된 자료->삭제, R: 가장 마지막에 삽입된 자료->추가
  - 데크: 스택+큐 특징, 양쪽에서 삽입/삭제 가능
- 비선형 구조(정점(vertex)과 연결하는 간선(edge)으로 구성)
  - 트리: 사이클이 없는 계층적 구조
  - 그래프: 방향 그래프/무방향 그래프 - 간선 수는 그림 그려서

### 37) 트리
- node와 link로 구성된 그래프의 특수 형태
- 개념: degree(차수, 뻗어나온 가지 수), 단말 노드, 트리의 차수(최대 차수)
- **운행법**: Preorder(root->left->right), Inorder(left->root->right), Postorder(left->right->root)
  풀이는 서브트리 단위로 묶어서 접근
- **수식 표기법**: 전위(연산자->left->right;Preorder 방향), 중위(left->연산자->right;Inorder 방향), 후위(left->right->연산자;Postorder 방향)
  - Infix는 스택을 이용해 처리하는 Postfix나 Prefix로 바꾸어 처리한다.
  => 변환방법: 연산순위에 따라 괄호로 묶음 -> 전위 표기법의 경우 연산자를 앞, 후위 표시법의 경우 연산자를 뒤로 보냄->괄호 제거
  - 반대로 Postfix나 Prefix로 표기된 수식을 Infix로 변환하는 방법
  => 피연산자 두개와 후위 표시법의 경우오른쪽 연산자를 괄호로 묶음 -> 피연산자 가운데로 이동

### 38) 정렬
- 삽입 정렬: 처음부터 순서대로 비교하여 나열, **n 번째 키를** n-1개 키와 비교하여 **알맞은 순서에 삽입**
  => 평균과 최악 모두 수행시간 복잡도: 평균과 최악 모두 O(n2)
- 쉘 정렬: 삽입 정렬 + **매개변수** 값으로 서브파일을 구성해 정렬, 부분 정렬되어 있는 경우 유리
  => 평균 수행시간 복잡도: O(n1.5), 최악 수행시간 복잡도: O(n2)
- 선택 정렬: **처음 레코드을 기준으로 하여 끝 레코드까지 최소값**을 찾아 첫 번째 레코드에 위치, 이후에도 반복
  => 평균과 최악 모두 수행시간 복잡도: O(n2)
- 버블 정렬: **인접한 두 레코드 키 값을 비교**하여 서로 교환
  => 평균과 최악 모두 수행시간 복잡도: O(n2)
- 퀵 정렬: **하나의 파일을 부분적으로 나누어** 가며 정렬, 정렬 방식 중에 가장 빠름, 분할과 정복(->분류)을 통해 정렬
  => 평균 수행시간 복잡도: O(nlog2n), 최악 수행시간 복잡도: O(n2)
- 힙 정렬: **전이진트리**를 이용한 정렬 방식, 노드의 **역순**으로 가서 자식 노드와 부모 노드를 큰 값을 위로 올림
  => 평균과 최악 모두 수행시간 복잡도: O(nlog2n)
- 2-way 합병 정렬: 이미 정렬된 두 개의 파일을 한 개의 파일로 합쳐 정렬, **두 개씩 내부에서 묶은 후** 정렬, 이를 반복
  => 평균과 최악 모두 수행시간 복잡도: O(nlog2n)
- 기수 정렬: 큐를 이용하여 자릿수별로 정렬, 버킷에 분배하였다고 순서대로 꺼내어 정렬
  => 평균과 최악 모두 수행시간 복잡도: O(dn)

### 39) 검색 - 이분 검색/해싱
- 이분 검색(Binary Search): 전체 파일을 두 개의 서브파일로 분리, 순서화된 파일 대상, 중간 레코드 key 값과 비교하며 검색, M = (F+L)/2 반복
- 해싱: 해시 테이블이라는 기억 공간을 할당하고, 해시 함수를 이용하여 데이터를 고유한 키에 매핑하여 저장 및 검색 수행
  - 해시 테이블: 버킷들로 구성된 기억 공간
  - 해싱 함수
    - 제산법: 레코드 키를 **해시표의 크기보다 큰 수 중 가장 작은 소수**로 나눈 나머지를 홈 주소로 삼는 방식
    - 제곱법: 레코드 키 값을 **제곱한 후 그 중간 부분 값**을 홈 주소로 삼는 방식
    - 폴딩법: 레코드 **키 값을 나눈 후 각 부분의 값을 더하거나 XOR한 값**을 홈 주소로 삼는 방식
    - 기수 변환법: 키 숫자 진수를 **다른 진수로 변환시켜 주소 크기를 초과한 자릿수는 절단**하고, 범위에 맞게 조정하는 방식
    - 대수적 코딩법: 키를 이루는 **각 자리 비트 수를 다항식 계수로 간주**하고, 다항식을 해시표 크기에 의해 정의된 다항식으로 얻은 나머지 다항식 계수를 홈 주소로 삼는 방식
    - 숫자 분석법: 키 값의 **숫자 분포를 분석해 비교적 고른 자리**를 택해서 홈 주소로 삼는 방식
    - 무작위법: **난수** 값을 홈 주소로 삼는 방식

### 40) 데이터베이스 개요
- 데이터저장소: 데이터를 논리적인 구조로 조직화(논리)하거나 물리적인 공간(물리)에 구축한 것 -> 데이터베이스 구축 과정과 동일
- 데이터베이스: 통합된 데이터(중복 배제), 저장된 데이터(컴퓨터 접근), 운영 데이터(고유 업무 수행에 반드시 필요), 공용 데이터(공동 소유 및 유지)
- DBMS
  - **정의** 기능: 타입과 구조에 대한 정의, 이용 방식, 제약 조건 명시
  - **조작** 기능: 삽입, 삭제, 갱신 등을 처리하기 위한 인터페이스 수단 제공
  - **제어** 기능: 무결성, 보안 및 권한 검사, 병행 제어
  - 장점: 종속성과 중복성의 배제
  - 단점: 전산화 비용 증가, 과부하, 예비/회복 어려움
- 스키마
  - DB 구조와 제약 조건에 관한 명세 기술 메타데이터 집합
    - 외부 스키마: 개인의 입장에서 필요로 하는 DB 논리적 구조 정의
    - 개념 스키마: DB 전체에 관한 논리 구조, 하나만 존재
    - 내부 스키마: 물리적 저장장치 입장에서 본 데이터베이스 구조, 저장될 레코드 형식 및 순서 정의 

### 41) 데이터 입출력
- 데이터 입출력을 위해 SQL(관계형 데이터베이스 지원 언어) 사용 -> Data Mapping(SQL Mapping;코드 내에 직접 sql 입력하여 dbms 데이터 접속, ORM;객체와 DB 데이터 연결)
- SQL 구분: DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어) -> DBMS 기능 참고
- 연산 단위: Transaction(TCL 명령어 사용; commit, rollback, savepoint 존재)

### 42) 절차형 SQL
: DB 전용 프로그래밍, 단일 SQL문으로 처리하기 어려운 연속적인 작업 처리에 적합,
DBMS 엔진에서 직접 실행되므로 입출력 패킷이 적음, BEGIN~END 형식으로 작성되는 Block 구조
- 종류: 프로시저(미리 저장한 작업 수행), 트리거(데이터 입력, 갱신, 삭제 등 이벤트가 발생할 때마다 관련 작업 자동 수행), 사용자 정의 함수(return을 사용해 처리 결과 단일값으로 반환)
- 테스트/디버깅: SHOW 명령어를 통해 문제 확인/수정, 디버깅은 주석 처리
- 최적화: APM을 사용해 쿼리 선정, 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성

### 43) 단위 모듈 구현
- 단위 모듈: 하나의 동작을 수행하는 기능(단위 기능)을 모듈화, 독립적 컴파일 가능
- 단위 기능 명세서 작성: 추상화하여 명세화, 정보 은닉의 원리 고려
- 입출력 기능 구현: 단위 모듈 간 연동 또는 입출력 데이터 구현
- 알고리즘 구현: 모듈로 구현(디바이스 드라이버;하드웨어 주변장치, 네트워크, 파일;내부 데이터 구조 영역에 접근, 메모리;가상 메모리에 파일을 매핑/해제하고 프로세스 사이 통신, 프로세스;하나의 프로세스에서 다른 프로세스 생성)
- IPC: 모듈 간 통신 방식 구현하기 위한 인터페이스 집합
  - 대표 메서드: Shared Memory, Socket, Semaphores(공유 자원에 대한 접근 제어), Pipes&named Pipes(선입선출 메모리), Message Queueing

### 44) 단위 모듈 테스트(Unit Test)
- 화이트박스 테스트(소스 코드 오픈한 상태로 논리적 경로 테스트), 블랙박스 테스트(기능 작동 테스트)
- 테스트 케이스: 테스트 항목에 대한 명세서
  - 구성 요소(ISO/IED 29119-3 표준): 식별자, 테스트 항목, 입력 명세, 출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술
- 테스트 프로세스 5단계: 계획/제어 -> 분석/설계(구체화 및 작성) -> 구현/실행(조합 및 도구 이용하여 수행) -> 평가 -> 완료(이후 테스트를 위한 기록/저장)

### 45) 개발 지원 도구
- 통합 개발 환경(IDE): 코딩, 디버깅, 컴파일, 배포를 하나의 프로그램에서 처리하도록 제공하는 소프트웨어
  ex) Eclipse(크로스 플랫폼), Visual Studio, Xcode(Mac), Android Studio, IDEA(크로스 플랫폼)
- 빌드 도구: 소스 코드 파일들을 실행할 수 있는 제품 소프트웨어로 변환하는 과정(전처리 및 컴파일)
  ex) Ant(아파치 개발, 자바의 공식 빌드 도구, XML 기반, 자유도와 유연성이 높음), Maven(아파치 개발, 컴파일과 빌드 동시 수행, 의존성 설정), Gradle(안드로이드 스튜디오 공식 빌드 도구, 의존성 활용, 그루비 기반 빌드 스크립트)
- 협업 도구
  - 프로젝트/일정 관리: 구글 캘린터, 지라, 분더리스트, 트렐로
  - 정보 공유/커뮤니케이션: 슬랙, 잔디
  - 디자인: 스케치, 피그마, 제플린